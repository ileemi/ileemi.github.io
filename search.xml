<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言函数间的工作原理</title>
    <url>/posts/4debd7e3/</url>
    <content><![CDATA[<p>函数的工作原理以及实现过程。<a id="more"></a></p>
<h3 id="break、continue的简单使用"><a href="#break、continue的简单使用" class="headerlink" title="break、continue的简单使用"></a>break、continue的简单使用</h3><p>break：如果在循环内有个if判断，其条件为false，那么就会跳出循环，不在执行<br>continue：如果在循环内有个if判断，其条件为false，那么就会跳过本次循环，继续执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">统计1~20之间不能被3整除的数的个数并输出这些数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> nCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt;= <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>, i);<br>        nCount++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1~20内的数字不能被3整除的数有 %d 个&quot;</span>, nCount);<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义变量时，如果没有合适的初值，那么就应该对其赋上一个对应类型的初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> f = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">int</span> *p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>100以内的质数<br>使用筛选法 用于求一段区间的所有质数<br>将不是素数的填充0，将2、3、5、7的倍数全部进行填充0</p>
<h3 id="函数-强内聚，低耦合"><a href="#函数-强内聚，低耦合" class="headerlink" title="函数(强内聚，低耦合)"></a>函数(强内聚，低耦合)</h3><p>微软函数命名规范：不带下划线的是标准函数，可以供外接进行调用。带下画线的是非标准函数，供内部进行调用（命名：根据依赖关系，如果函数名前有一个下划线，表示一层依赖关系，两个表示有两层依赖关系）。</p>
<ul>
<li>熟悉函数的语法</li>
<li>熟悉函数的调用机制</li>
<li>合理的设计各个函数模块（难），需要有足够的项目失败经验</li>
</ul>
<p><strong>强内聚，低耦合</strong></p>
<p>内聚：所需资源自给自足，不依赖其它的模块。可以方便地移植到其它工作所需地模块中，重用性强。<br>内聚强的，责任清晰，一看到错误即可定位到某个具体模块中的具体函数中，将来debug难度较小</p>
<p>耦合：资源之间（全局变量）相互依赖，单一模块无法完成单一功能。难以方便地移植到其它工作所需地模块中，重用性较差。<br>耦合性高的，责任不清晰，将来debug难度较大。例如：街边爆米花</p>
<p>UI：User Interface 把编程的业务和界面分离</p>
<p>函数只做算法，UI交给用户</p>
<p><strong>定义函数时需要给函数进行以下注释：</strong></p>
<ul>
<li>简要说明函数的功能和意义</li>
<li>描述函数的各个参数意义</li>
<li>描述返回值的意义</li>
<li>备注该函数的注意事项和其它的幺蛾子情况</li>
<li>修改的版本信息（据公司规定）</li>
</ul>
<p><strong>实例：</strong><br>输出100以内的素数</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数判定一个数是否是质数</span><br><span class="hljs-comment">参数：int nNumber：(in) 需要判定的数值</span><br><span class="hljs-comment">返回值：如果是质数，则返回1，否则返回0</span><br><span class="hljs-comment">幺蛾子：本函数不检查参数的有效性，其检查责任由调用者负责</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nNumber)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> isPrime = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> nEnd = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(nNumber);<br>    <span class="hljs-keyword">if</span> (nNumber == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> isPrime;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= nEnd; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nNumber % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            isPrime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isPrime;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> nCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (nCount = <span class="hljs-number">2</span>; nCount &lt;= <span class="hljs-number">100</span>; nCount++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(IsPrime(nCount))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, nCount);<br>            n++;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>  system(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><p>解决问题的依赖关系：<br>A-&gt;B-&gt;C-&gt;D  返回：D-&gt;C-&gt;B-&gt;A<br><img src="1.png"><br>栈结构的这种特性可以记录函数的依赖关系<br>堆和栈是两回事：如果没有特殊说明 “堆栈”表示的就是栈，例如：牛奶、奶牛</p>
<h3 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h3><p> 1、需要维护一个栈结构用于记录函数的调用依赖关系，便于执行完内层函数后，知道流程应该回到哪里。<br> 2、按照双方的调用约定进行传参</p>
<ul>
<li>调用方称为：caller，被调用方称为 callee，caller在调用callee前需要双方约定调用细节</li>
<li>调用约定：（1）约定函数参数的传递顺序（2）参数的存储媒介（栈或者寄存器）（3）谁负责释放参数空间（有且仅有一方去实施）（4）返回值的存储媒介（栈或者寄存器）</li>
<li>调用约定，例如：__cdecl ，修饰在返回值后，函数名前，表示该函数使用C约定，在工程设置里默认情况下使用C约定<br><img src="2.png"><br><img src="3.png"></li>
</ul>
<p><strong>__cdecl(C约定)</strong></p>
<ul>
<li>函数参数按从右往左的方向传递</li>
<li>使用栈空间传递参数</li>
<li>右 caller 负责释放参数空间</li>
<li>返回值在寄存器中</li>
</ul>
<p><strong>__stdcall(标准调用约定)</strong></p>
<ul>
<li>函数参数按从右往左的方向传递</li>
<li>使用栈空间传递参数</li>
<li>右 callee 负责释放参数空间</li>
<li>返回值在寄存器中</li>
</ul>
<p><strong>__fastcall(快速调用约定)</strong></p>
<ul>
<li>左数前两个参数使用寄存器传递，其余各参数使用栈从右往左的方向传递</li>
<li>右 callee 负责释放参数空间</li>
<li>返回值在寄存器中</li>
<li>如果函数的参数只有两个，那么这两个参数就直接走寄存器</li>
</ul>
<p>从右往左就是参数从最右往左的顺序依次放入到栈中</p>
<p><strong>寄存器</strong><br>CPU中的存储单元，价格昂贵但是其访问速度快</p>
<p>3、保存函数返回后应该执行的代码地址，简称“返回地址”。<br>记录回家的地址<br>4、保存调用方 caller 的栈地址。<br>5、更新当前栈底到 被调用方 callee的栈位置。<br>6、为局部变量申请栈空间（使用栈保存局部变量）。<br><strong>7</strong>、/Zi 或者 /ZI (/Od) 编译选项会把局部变量的空间初值设为0xcccccccc（烫烫烫烫）debug自带/Zi 生成调试信息， /Od 禁用优化（没有初始化的局部变量就是栈上的随机值）<br>/Zi 编辑且继续的调试信息（调试程序时，修改程序后，不用重新编译，可继续调试）<br>烫：调试版下未初始化的局部变量</p>
<p><img src="4.png"></p>
<p>8、保存其它受影响的寄存器（/Zi 或者 /ZI 编译选项稳定保留12个字节（3个寄存器，一个寄存器4字节））<br>（指函数中使用寄存器会提前保存）12字节：别的寄存器有可能被这个函数覆盖的其它寄存器中的值<br>9、执行函数体</p>
<p><img src="5.png"></p>
<h3 id="分析函数间的调用关系"><a href="#分析函数间的调用关系" class="headerlink" title="分析函数间的调用关系"></a>分析函数间的调用关系</h3><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数判定一个数是否是质数</span><br><span class="hljs-comment">参数：int nNumber：(in) 需要判定的数值</span><br><span class="hljs-comment">返回值：如果是质数，则返回1，否则返回0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nNumber)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> isPrime = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> nEnd = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(nNumber);<br>    <span class="hljs-keyword">if</span> (nNumber == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> isPrime;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= nEnd; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nNumber % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            isPrime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isPrime;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nMin, <span class="hljs-keyword">int</span> nMix)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> nCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (nCount = nMin; nCount &lt;= nMix; nCount++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(IsPrime(nCount))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, nCount);<br>            n++;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//main函数为调用方</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//ShowPrime为被调用方</span><br>    ShowPrime(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ShowPrime函数栈结构"><a href="#ShowPrime函数栈结构" class="headerlink" title="ShowPrime函数栈结构"></a>ShowPrime函数栈结构</h4><p><img src="6.png"></p>
<h4 id="main函数栈结构"><a href="#main函数栈结构" class="headerlink" title="main函数栈结构"></a>main函数栈结构</h4><p><img src="7.png"></p>
<p>每个函数都有返回地址，如果没有返回地址，可以说这个函数”回不了家”。</p>
<p><strong>单步从main函数走，在没有从main函数内调用其它子函数时，main函数的栈结构如下：</strong></p>
<p><img src="8.png"></p>
<p>当main函数内未调用文件内的子函数时，在内存中只能看到main函数的栈结构，如果调用了子函数，内存就会更新，之后就可以看到main函数及子函数的栈数据</p>
<p><strong>ShowPrime函数的栈结构</strong></p>
<p><img src="9.png"></p>
<p><strong>Isprime函数的栈结构</strong></p>
<p><img src="10.png"></p>
<p>通过内存可以发现局部变量分配的空间远大于我们使用的空间</p>
<h4 id="使用Winhex分析函数之间调用的关系"><a href="#使用Winhex分析函数之间调用的关系" class="headerlink" title="使用Winhex分析函数之间调用的关系"></a>使用Winhex分析函数之间调用的关系</h4><p><img src="11.png"></p>
<h4 id="分析自己的Test程序内函数之间的调用关系"><a href="#分析自己的Test程序内函数之间的调用关系" class="headerlink" title="分析自己的Test程序内函数之间的调用关系"></a>分析自己的Test程序内函数之间的调用关系</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数用来计算nNumber1到nNumber2的累加和</span><br><span class="hljs-comment">参数nNumber1为累加初值，nNumber2为累加的最大值</span><br><span class="hljs-comment">计算结果返回0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Test1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nNumber1, <span class="hljs-keyword">int</span> nNumber2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\r\n&quot;</span>, &amp;result);  <span class="hljs-comment">//0012FF20</span><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">for</span> (; nNumber1&lt;= nNumber2; nNumber1++)<br>    &#123;<br>        result += nNumber1;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//main函数为caller</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test1(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//Test1为callee</span><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="12.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C语言函数间的工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和结构体</title>
    <url>/posts/5fab7dcc/</url>
    <content><![CDATA[<p>数组以及结构体的简单操作。<a id="more"></a></p>
<h3 id="程序就是数据结构加算法"><a href="#程序就是数据结构加算法" class="headerlink" title="程序就是数据结构加算法"></a>程序就是数据结构加算法</h3><p>数据结构：就是数据再计算机中的存储方式<br>算法：对数据进行各种处理</p>
<!--more-->

<p>数据的存储：<br>1、声明变量<br>2、数组和数组的排序<br>3、分配内存，使用指针、</p>
<h3 id="课前回顾"><a href="#课前回顾" class="headerlink" title="课前回顾"></a>课前回顾</h3><p><strong>货币牌价本版演变</strong><br>1、Visual 1：一次获取一个指定货币的一个价格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// visual 1：一次获取一个货币的一个价格</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  double ConvertCurrency(bool real, const char* from, const char* to, double </span><br><span class="hljs-comment">  amount);</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">double</span> result = ConvertCurrency(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;USD&quot;</span>, <span class="hljs-string">&quot;CNY&quot;</span>, <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\r\n&quot;</span>, result);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="1.png"></p>
<p>2、Visual 2：一次获取一个指定货币的多项数据(中文名、发布时间、以及5个价格)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  函数名：GetBOCRatesByCode</span><br><span class="hljs-comment">  用途：根据货币的代码获取这个货币最新的价格（5个）</span><br><span class="hljs-comment">  int GetBOCRatesByCode(const char* code, char* name, char* updateTime, double* </span><br><span class="hljs-comment">  data);</span><br><span class="hljs-comment">  const char* code   要获取价格的货币代码(使用const是不希望传递进去的字符串被GetBOCRatesByCode()这个函数无意的修改)</span><br><span class="hljs-comment">  char* name;    存储货币的中文名的内存地址</span><br><span class="hljs-comment">  char* updateTime;  存储发布时间的内存地址</span><br><span class="hljs-comment">  double* date；   储5个价格的存储空间的首地址 </span><br><span class="hljs-comment">  返回值：获取成功返回1，获取失败返回0</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">// 申请空间，存储对应的数据</span><br><br>  <span class="hljs-keyword">char</span>* name = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>);<br>  <span class="hljs-keyword">char</span>* updateTime = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">double</span>* rates = (<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * <span class="hljs-number">5</span>);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  // 等价于上面的指针</span><br><span class="hljs-comment">  char name[32];</span><br><span class="hljs-comment">  char updateTime[20];</span><br><span class="hljs-comment">  double rates[5];</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  上面的两种做法都是在内存中分配一块内存空间，然后再使用它</span><br><span class="hljs-comment">  不同之处:</span><br><span class="hljs-comment">  malloc()函数是在堆上分配内存</span><br><span class="hljs-comment">  数组是在栈上分配内存</span><br><span class="hljs-comment">  声明方式不同，但是使用方式基本一致</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-comment">// 调用BOCRates头文件里的GetBOCRatesByCode()函数</span><br>  <span class="hljs-comment">// 添加判断条件 检查内存空间的申请情况</span><br>  <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">NULL</span> &amp;&amp; updateTime != <span class="hljs-literal">NULL</span> &amp;&amp; rates != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-keyword">int</span> result = GetBOCRatesByCode(<span class="hljs-string">&quot;USD&quot;</span>, name, updateTime, rates);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  直接打印，VS会告诉我们 name、updataTome、rates都有可能分配内存失败 有可能为空值</span><br><span class="hljs-comment">  printf(&quot;%s\t%s\t%f\t%f\t%f\t%f\t%f\r\n&quot;, name, updataTime, *(rates), </span><br><span class="hljs-comment">  *(rates + 1), *(rates + 2), *(rates + 3), *(rates + 4));</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t%s\t%f\t%f\t%f\t%f\t%f\r\n&quot;</span>, name, updateTime, *(rates), *(rates + <span class="hljs-number">1</span>), *(rates + <span class="hljs-number">2</span>), *(rates + <span class="hljs-number">3</span>), *(rates + <span class="hljs-number">4</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;网络连接失败！&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(name);<span class="hljs-comment">// 释放申请的内存空间</span><br>    <span class="hljs-built_in">free</span>(updateTime);<br>    <span class="hljs-built_in">free</span>(rates);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存不足或者超出系统限制！\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="2.png"></p>
<p><strong>数组和指针</strong></p>
<p>数组和指针都是在内存中分配一块内存空间，然后使用它。所不同的是malloc()函数是在堆上分配内存，而数组是在栈上分配内存，数组名会自动被转换成数组空间的首地址。两者除了声明方式不同，使用方式基本一致：<br>指针：堆 屯<br>数组：栈 烫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 指针表示</span><br><span class="hljs-keyword">char</span>* name = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>);<br><span class="hljs-keyword">char</span>* updateTime = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">double</span>* rates = (<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 数组表示 等价于上面的指针</span><br><span class="hljs-keyword">char</span> name[<span class="hljs-number">32</span>];<br><span class="hljs-keyword">char</span> updateTime[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
<p><img src="5.png"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组就是为我们提供了一种在内存上方便的访问数据的方式，数组的数组的名称相当于数组第一个元素的首地址。字符数组是存储在栈上的，如果声明数组时没有初始化，数组内填的值和声明指针未初始化的值不一样的，指针的时屯，数组的是烫：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> str[<span class="hljs-number">256</span>];<br>  str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;     <span class="hljs-comment">// *str = &#x27;H&#x27;;</span><br>  str[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>  <span class="hljs-comment">// 打印字符数组str，由于初始化了字符数组的第一、第二元素的值，所以其值会正常打印，未初始化的元素会打印烫烫烫烫烫烫烫烫烫···，知道遇到 &#x27;\0&#x27;才会结束打印。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果如下：<br><img src="3.png"></p>
<p><strong>数组的内存空间无需手动释放，因为栈的空间比较小(1MB/2MB)多以数组不能定义的很大</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> str[<span class="hljs-number">1024</span> *<span class="hljs-number">1024</span> *<span class="hljs-number">1024</span>];<br>  str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;     <span class="hljs-comment">// *str = &#x27;H&#x27;;</span><br>  str[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果如下：<br><img src="4.png"></p>
<p><strong>数组是一种存储多个相同类型数据的数据结构，相对于之前的直接分配内存，数组这种存储方式使用的更加简单，不容易出错，数组的大小必须在声明的到时候就确实，不可以通过变量来确定数组的大小</strong></p>
<h3 id="将数组中最大元素的值保存到第一个数组元素中"><a href="#将数组中最大元素的值保存到第一个数组元素中" class="headerlink" title="将数组中最大元素的值保存到第一个数组元素中"></a>将数组中最大元素的值保存到第一个数组元素中</h3><p><strong>分析：</strong><br><img src="6.png"></p>
<p><strong>代码实现：</strong></p>
<p><strong>Visual 1：初级版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>];<br>  arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<span class="hljs-comment">// *str = 10;</span><br>  arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  arr[<span class="hljs-number">2</span>] = <span class="hljs-number">-3</span>;<br>  arr[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br>  arr[<span class="hljs-number">4</span>] = <span class="hljs-number">23</span>;<br>  <span class="hljs-comment">// 交换数值</span><br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) <br>  &#123;<br>    <span class="hljs-keyword">int</span> Temp = arr[<span class="hljs-number">0</span>];<br>    arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">1</span>];<br>    arr[<span class="hljs-number">1</span>] = Temp;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">2</span>])<br>  &#123;<br>    <span class="hljs-keyword">int</span> Temp = arr[<span class="hljs-number">0</span>];<br>    arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">2</span>];<br>    arr[<span class="hljs-number">2</span>] = Temp;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">3</span>]) <br>  &#123;<br>    <span class="hljs-keyword">int</span> Temp = arr[<span class="hljs-number">0</span>];<br>    arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">3</span>];<br>    arr[<span class="hljs-number">3</span>] = Temp;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">4</span>]) <br>  &#123;<br>    <span class="hljs-keyword">int</span> Temp = arr[<span class="hljs-number">0</span>];<br>    arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">4</span>];<br>    arr[<span class="hljs-number">4</span>] = Temp;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">3</span>], arr[<span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="7.png"></p>
<p><strong>Visual 2：指针版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> Temp = *a;<br>  *a = *b;<br>  *b = Temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>];<br>  arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<span class="hljs-comment">// *str = 10;</span><br>  arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  arr[<span class="hljs-number">2</span>] = <span class="hljs-number">-3</span>;<br>  arr[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br>  arr[<span class="hljs-number">4</span>] = <span class="hljs-number">23</span>;<br>  <span class="hljs-comment">// 交换数值</span><br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">2</span>]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">2</span>]);<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">3</span>]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">3</span>]);<br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">4</span>]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">4</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[0] = %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="7.png"></p>
<p>使用for()循依次比较数组元素的值，最后将最大值存储到arr[0]里，并输出，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> Temp = *a;<br>  *a = *b;<br>  *b = Temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">23</span>&#125;;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  arr[0] = 10;// *str = 10;</span><br><span class="hljs-comment">  arr[1] = 2;</span><br><span class="hljs-comment">  arr[2] = -3;</span><br><span class="hljs-comment">  arr[3] = 13;</span><br><span class="hljs-comment">  arr[4] = 23;</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">// 使用for()循环依次遍历交换数值</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">4</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[i]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[0] = %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果为：<br><img src="7.png"></p>
<h4 id="将数组内的所有元素按从大到小的顺序输出"><a href="#将数组内的所有元素按从大到小的顺序输出" class="headerlink" title="将数组内的所有元素按从大到小的顺序输出"></a>将数组内的所有元素按从大到小的顺序输出</h4><p>Visual 1：入门版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> Temp = *a;<br>  *a = *b;<br>  *b = Temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>];<br>  arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">// *str = 10;</span><br>  arr[<span class="hljs-number">1</span>] = <span class="hljs-number">23</span>;<br>  arr[<span class="hljs-number">2</span>] = <span class="hljs-number">-3</span>;<br>  arr[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br>  arr[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 交换数值</span><br>  <span class="hljs-comment">// 1.将数组内最大的数值存储到arr[0]里面</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">4</span>; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &lt; arr[i]) swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>  &#125;<br>  <span class="hljs-comment">// 2.将数组内第2大的数值存储到arr[1]里面</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">4</span>; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] &lt; arr[i]) swap(&amp;arr[<span class="hljs-number">1</span>], &amp;arr[i]);<br>  &#125;<br>  <span class="hljs-comment">// 3.将数组内第3大的数值存储到arr[2]里面</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= <span class="hljs-number">4</span>; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">2</span>] &lt; arr[i]) swap(&amp;arr[<span class="hljs-number">2</span>], &amp;arr[i]);<br>  &#125;<br>  <span class="hljs-comment">// 4.将数组内第4大的数值存储到arr[3]里面</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= <span class="hljs-number">4</span>; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">3</span>] &lt; arr[<span class="hljs-number">4</span>]) swap(&amp;arr[<span class="hljs-number">3</span>], &amp;arr[<span class="hljs-number">4</span>]);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">3</span>], arr[<span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序循行结果：<br><img src="8.png"></p>
<p>VIsual 2：进阶版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> Temp = *a;<br>  *a = *b;<br>  *b = Temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>];<br>  arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// *str = 10;</span><br>  arr[<span class="hljs-number">1</span>] = <span class="hljs-number">23</span>;<br>  arr[<span class="hljs-number">2</span>] = <span class="hljs-number">-3</span>;<br>  arr[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br>  arr[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">4</span>; j ++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) swap(&amp;arr[i], &amp;arr[j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">3</span>], arr[<span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="8.png"></p>
<p>Visual 3：迭代版<br>如果数组内的元素不确定，且考虑到程序的移植性，所以还需要在上面的代码中进行如下改动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> Temp = *a;<br>  *a = *b;<br>  *b = Temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 数组的名称相当于数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">10</span>, <span class="hljs-number">78</span>, <span class="hljs-number">23</span>, <span class="hljs-number">-34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">77</span>, <span class="hljs-number">-233</span>, <span class="hljs-number">20</span> &#125;;<br>  <span class="hljs-keyword">int</span> count = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 添加这句代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= count <span class="hljs-number">-2</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= count<span class="hljs-number">-1</span>; j ++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) swap(&amp;arr[i], &amp;arr[j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d\r\n&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">3</span>], arr[<span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果如下：<br><img src="9.png"></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>使用数组、指针只能存储同种类型的数据。如何将不同类型的数据化零为整？只能通过<strong>自定义数据类型（结构体）</strong>。<br>使用结构体可以存储不同类型的多项数据。<br><strong>结构体就是一个由多个变量多个数组组成的大的数据类型</strong><br><strong>数组</strong>是将<strong>相同类型</strong>的多项数据集合在一起的方式，而<strong>结构体</strong>是将多种<strong>不同类型</strong>的数据项集合到一起的方法。<br>在此之前我们使用的整型，浮点型都是C语言的内置数据类型，一个变量只能存储一项数据。但是在很多时候我们还需要把多项不同类型的数据合并成一个整体来进行操作。<br>例如：<br>存储一个人的个人信息，需要定义下面的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">char</span> name[<span class="hljs-number">32</span>];  <span class="hljs-comment">// 该字符数组用于存储个人姓名</span><br><span class="hljs-keyword">char</span> id[<span class="hljs-number">32</span>];    <span class="hljs-comment">// 该字符数组用于存储个人的身份证</span><br><span class="hljs-keyword">int</span> gender = <span class="hljs-number">1</span>; <span class="hljs-comment">// 该整型变量可以用来存储该人的性别</span><br><span class="hljs-keyword">int</span> age;        <span class="hljs-comment">// 该整型变量用来存储年龄</span><br></code></pre></td></tr></table></figure>
<p>上面的四个变量和数组在程序上可以说是独立的，如果需要像一个函数传递某个人的个人信息，这个函数就需要对应的四个参数，这就会让写的程序变得很冗长，有时候增加一个需求，比如增添个人的手机号，户籍地等，就需要在函数内添加参数，而同时还需要再程序中需改多处，就会显得特别麻烦。<br>而<strong>结构体变量</strong>就可以将多个有关联的变量、数组合并成一个变量，这个变量可以分成多个部分，用于存储不同信息。<br><strong>结构体的定义形式为：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名</span><br><span class="hljs-class">&#123;</span>  <br>  结构体所包含的变量或数组<br>&#125;;<br><span class="hljs-comment">// 例如：外汇币种的对应信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EXCHANGE_RATE</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> CurrencyCode[<span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">char</span> CurrencyName[<span class="hljs-number">32</span>];<br>  <span class="hljs-keyword">char</span> PublishTime[<span class="hljs-number">20</span>];<br>  <span class="hljs-keyword">double</span> BuyingRate = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> CashBuyingRate = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> SellingRate;<br>  <span class="hljs-keyword">double</span> CashSellingRate;<br>  <span class="hljs-keyword">double</span> MiddleRate;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">typedef struct EXCHANGE_RATE ExchangeRate</span><br><span class="hljs-comment">使用typedef 可以给结构体变量起一个别名 基于这个结构体为结构体定义一个类型名</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EXCHANGE_RATE</span> <span class="hljs-title">r</span>;</span> <span class="hljs-comment">//  r为EXCHANGE_RATE结构体的变量名</span><br>  ReadBOCRatesByCode(<span class="hljs-string">&quot;HKD&quot;</span>, &amp;r);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyCode);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyName);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.PublishTime);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.BuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.SellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashBuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashSellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t\n&quot;</span>, r.MiddleRate);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="10.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数组与结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客绑定个人域名</title>
    <url>/posts/5b60be46/</url>
    <content><![CDATA[<p>将自己的blog绑定自己购买的域名。<a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前些天使用Hexo框架在Github pages上搭建了一个自己的个人博客，在访问我的博客时需要输入GitHub下的二级域名才能进行访问，例如：<code>ileemi.github.io</code>。首先我觉得这个二级域名看着就有点不自然，名字有点长了，看一眼不太好记。更换个新的域名就是为了使我的博客域名更加好记，更加具有独特性，所以我就去阿里的万网购买了一个新的域名，今天我把博客从原来使用的GitHub二级域名更换为我新买的个人域名。<br>这样一来，我就可以直接在浏览器上输入新买的域名来访问我的博客，想看我博客的同学们也就不用再输入那长长的域名了，接下来我就把整个更换的过程记录一下吧。</p>
<!--more-->

<h3 id="域名的购买"><a href="#域名的购买" class="headerlink" title="域名的购买"></a>域名的购买</h3><p>关于域名的购买，我看网上都有教程。能买域名的平台也挺多的，国内的域名服务商有腾讯云、新网、阿里的万网等等。想要购买的域名可以说是全球唯一的，在这些平台上都可以搜索到。各家每段时间都会有优惠，所以大家要买的话可以进行下对比，参考参考。我是在阿里的万网上购买的，所以这里就以阿里的万网为例。<br>域名购买的过程我就不赘述了，在<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.24.55484f159OAH4J">阿里万网</a>注册账号，搜索心怡的域名，购买成功后，进入阿里云的<code>管理控制台-&gt;域名(域名服务)-&gt;域名列表</code>，这个时候我们就可以看到我们刚才购买的域名了，接着还需要对购买的域名进行实名认证(不认证不能使用)，认证过程大概2个小时左右，如下图所示：<br><img src="20200226142720.jpg"></p>
<h3 id="进行域名解析"><a href="#进行域名解析" class="headerlink" title="进行域名解析"></a>进行域名解析</h3><p>找到购买的域名，然后点击”解析”就会跳转到<code>云解析DNS</code>页面，如下图所示:<br><img src="20200226143201.jpg"><br>打开Windows的命令行工具，<code>ping</code>我们的<code>GitHub</code>二级域名获取相应的<code>IP</code>地址以及我们购买的域名相应的<code>IP</code>地址，操作如下：<br><img src="ip.jpg"><br>进入阿里云的<code>云解析DNS-&gt;域名解析-&gt;解析设置</code>，进行如下配置：<br><img src="dns.jpg"><br><code>记录类型</code>需要有两个<code>A</code>，一个<code>CNAME</code>，两个<code>记录类型 A</code>的”记录值”分别填写刚才<code>ping GitHub和新购买域名得到的IP</code>。<code>记录类型 CNAME</code>的记录值填写我们的<code>GitHub的二级域名</code>即可，<code>解析线路(isp)</code>和<code>TTL</code>默认即可，不做更改。</p>
<h3 id="新建CNAME文件"><a href="#新建CNAME文件" class="headerlink" title="新建CNAME文件"></a>新建CNAME文件</h3><p>在我们博客的根目录下找到<code>source</code>文件夹，双击进入该文件夹，然后新建一个名为<code>CNAME</code>的文件，用记事本或者notepad++打开，输入我们购买的域名并保存，该文件不需要加任何后缀。保存的域名可加也不可加<code>www</code>，区别在于，加<code>www</code>的话，在我们访问我们的博客时需要我们输入<code>www.xxx.xx</code>(如果不写www访问失败)。不加<code>www</code>，我们在访问博客时可以直接输入购买的域名进行访问(这种情况可以加<code>www</code>也可以不加<code>www</code>，就可以访问我们的博客)。<br><img src="CNAME.jpg"></p>
<h3 id="在GitHub上进行相关设置"><a href="#在GitHub上进行相关设置" class="headerlink" title="在GitHub上进行相关设置"></a>在GitHub上进行相关设置</h3><p>登录我们的GitHub账号，找到存储我们博客的存储库，找到<code>Settings-&gt;GitHub Pages</code>,进行如下操作：<br><img src="20200226154451.jpg"></p>
<p>到这里我们就可以依次运行下面的三个命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo clear<br>heox generate<br>heox deploy<br></code></pre></td></tr></table></figure>
<p>然后就可以在浏览器搜索栏输入我们新买的域名来访问我们的博客了，示例：<br><img src="20200226155002.jpg"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客绑定个人域名</tag>
      </tags>
  </entry>
  <entry>
    <title>VC++ 6.0的简单使用及switch case内部优化方案</title>
    <url>/posts/7f4048e6/</url>
    <content><![CDATA[<p>VC++ 6.0远古级IDE的使用，C语言switch case的内部优化。<a id="more"></a></p>
<h3 id="VC-6-0-文件的创建"><a href="#VC-6-0-文件的创建" class="headerlink" title="VC++ 6.0 文件的创建"></a>VC++ 6.0 文件的创建</h3><ul>
<li>第一步：打开Microsoft Visual C++ 6.0</li>
<li>第二步：点击左上角的File、New </li>
<li>第三步：点击File栏下的C++ Source File，之后输入对应的文件名及文件存放目录即可创建一个新的<code>.c</code>文件</li>
</ul>
<p><img src="1.jpg"></p>
<h3 id="VC-6-0-快捷键的使用"><a href="#VC-6-0-快捷键的使用" class="headerlink" title="VC++ 6.0 快捷键的使用"></a>VC++ 6.0 快捷键的使用</h3><ul>
<li>F1：调出MSDN（查询函数帮助文档）</li>
<li>F5：编译后调试运行 </li>
<li>F7：编译 + 链接 </li>
<li>F9：当前行添加/取消断点 </li>
<li>F10：步过（单步走）</li>
<li>F11：步入（单步进入，查看函数实现的功能）</li>
<li>CTRL + F5：直接运行 </li>
<li>CTRL + F7：只编译不链接 </li>
<li>Shift + F11：Step out（跳出）</li>
<li>CTRL + F10：单步跳转到鼠标点击的光标处 </li>
<li>ALT + 8：跳转到反汇编代码窗口</li>
<li>IDE（Integrated Development Environment）：集成开发环境</li>
</ul>
<h4 id="操作示例："><a href="#操作示例：" class="headerlink" title="操作示例："></a>操作示例：</h4><p>VC++ 6.0菜单栏的调整：<br><img src="2.jpg"></p>
<p>VC++ 6.0 调试程序时，需要使用的窗口：内存窗口、监视窗口、堆栈窗口、寄存器窗口。<br><img src="3.jpg"></p>
<p>在编写程序是，可以将鼠标的光标放置在想要了解的库函数上，按F1键，即可弹出MSDN帮助文档。<br><img src="4.jpg"></p>
<p>VC++ 6.0 使用Alt + 8 打开当前行的反汇编窗口，同时还可以鼠标右击该窗口，点击”Code Bytes” 查看对应的机器码。<br><img src="5.jpg"></p>
<p>Windows XP 下使用VC++ 6.0 查看内存的分布，可以发现内存4GB空间的前2GB有前64KB、后64KB的内存空间是属于系统保留区，前64KB用来做无效指针，无效赋值的检查，后64KB用来做内核的交互。<br><img src="6.jpg"></p>
<h3 id="API-PK-库函数"><a href="#API-PK-库函数" class="headerlink" title="API PK 库函数"></a>API PK 库函数</h3><p>看环境：如果没有造缓存， fread 就比 库函数的执行效率要慢一点。<br>malloc（C库函数） –&gt;  HeapAlloc（API函数）<br>不同平台的C编译器会对这个平台接口做一定的封装工作。</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>可以做复杂的条件判断、可以设定条件的优先级（将执行数据量大的条件放置在前面）、可做区间判断、使用灵活。<br>缺点：阶梯比较，如果数量比较次数较多的话，就没有switch case效果好。<br><img src="7.jpg"></p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><p>case 的值必须是整型系：整数或者类整型 ASCII（‘A’），long（5L）型都可以。<br>switch语句是一个优化版的分支结构，在汇编的年代这个结构很多人在用，后来C/C++标准委员会觉得这个结构很实用，之后就将其集成到C语言的语法框架里，之后将其命名为switch结构。俩次到位，第一次求得switch表达式中的值，根据值访问内存中对应的地址表进行跳转。</p>
<p>switch case内部优化方案之一（连续或较为连续方案）<br><img src="8.jpg"></p>
<p>当case值按正顺序排列时在内存中的分布情况如下<br><img src="9.jpg"><br>发现在内存地址表中，存储的case值下对应的代码地址是连续的</p>
<p><strong>基本结构思想：根据switch中表达式的值，找到内存中case内存地址表的对应的下标值。</strong></p>
<p>当打乱case 值进行逆序排列后，内存中的分布情况如下<br><img src="10.jpg"><br>即使case 后的值顺序进行了更改，但是通过case 的内存地址表可以发现，case值依然是顺序排列的。</p>
<p>将case值进行调大，打乱顺序，case值没有间隔：<br><img src="11.jpg"><br><img src="12.jpg"></p>
<p>通过反汇编窗口可以发现case值从20开始，前20是空值，就像数组中的前20元素是空值一样，存储空值是没有意义的，所以系统内部进行了坐标平移，即使case值顺序打乱后，通过case 内存地址表可以发现，其值依然是按循序进行排列的</p>
<p>将case值设定为不连续的，中间进行跳值，case值从20到28，去掉23、25、27<br><img src="13.jpg"><br><img src="14.jpg"><br>通过case 地址内存表的地址以及反汇编窗口可以发现，其case值依旧是连续排列的，中间缺少的值case 23、case 25、case27都用default下的语句地址进行了填充。</p>
<p>将case值与值之间间隔设置5个（超过5个）<br><img src="15.jpg"><br><img src="16.jpg"><br>可以看出case值在内存中的分布已经不在连续了</p>
<h3 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h3><ul>
<li>每个switch case分支的访问效率均等</li>
<li>不管怎样调整case的位置都不会影响它们的访问效率</li>
</ul>
<p>switch case 结构有四套优化方案，上面演示的就是连续或较为连续的方案：case的数量需要大于三个，只有这样才有优化行为，case 的值需要连续，如果不连续，中间欠缺的值不能超过5个，如果超过5个或者等于5个，那么其在内存中就不是连续存储的。<br>case 的值不能为小数是因为其在内存中存储的结构类似于数组的存储结构，需要根据switch表达式的值在内存中进行查表，基于此，case 的值必须是类整型。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VC++ 6.0 的简单使用</tag>
        <tag>switch case 的内部优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程总结</title>
    <url>/posts/e1fa0632/</url>
    <content><![CDATA[<p>Windows编程课程总结。<a id="more"></a></p>
<h3 id="课前回顾"><a href="#课前回顾" class="headerlink" title="课前回顾"></a>课前回顾</h3><p>单个钩子不可以拦截消息<br>钩子配合SetWindowLong可以做到拦截消息</p>
<p>全局钩子需要配合dll，随机基址等于主模块变成dll，可以下全局钩子。</p>
<p>钩取指定线程，需要在SetWindowsHookEx参数4中填写对应的线程ID。</p>
<p>ToAscii – 将指定的虚拟键代码和键盘状态转换为对应的一个或多个字符。该函数使用输入语言和由键盘布局句柄标识的物理键盘布局来翻译代码。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>做一个打印机服务，计算机中的所有进程都可以控制打印机去打印。<br>可以创建一个窗口程序，也可以创建一个线程，但是当程序关闭的时候，这个程序就关闭了，使用的时候还需要打开启动。考虑到要随用随启动，也就服务程序符合要求。</p>
<p>线程和进程是绑定的，进程没了，线程也就没了，为了去适合需要服务的程序，可以将其写成服务，可以隐藏，可以开启启动。服务也算是一个进程。</p>
<p>服务也有程序入口，可以通过命令行参数来确定服务是安装还是启动，安装，启动写在一个工程中。</p>
<p>将安装服务和启动服务写在一个工程中，可以通过命令行参数来区分是安装服务还是启动服务。安装的时候通过命令行参数，启动的时候通过 ServiceMain 。</p>
<blockquote>
<p>通过命令行运行可执行程序并输入参数来确定是打开服务还是创建服务：<br>xxx.exe 参数<br>示例：Service.exe install</p>
</blockquote>
<p>服务的启动需要有对应的入口函数，为了不和控制台的 main 函数冲突，就可以通过 StarServiceCtrlDispatcher 将 main 函数转换成 ServiceMain 来使用。</p>
<p>服务的入口函数是 – ServiceMain</p>
<h4 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h4><ol>
<li>给一个命令行参数</li>
<li>打开SCM服务管理器 – OpenSCManger(参数1，2 – NULL, 参数3 – 所有权限)</li>
<li>使用API CreateService （安装服务就是创建服务）参数1 – 打开SCM服务管理器返回的句柄</li>
</ol>
<p>写服务程序的三个基本操作：</p>
<ol>
<li>将 main 函数转换成 ServiceMain</li>
<li>写 ServiceMain 服务入口</li>
<li>在 ServiceMain 中注册一个服务控制句柄</li>
</ol>
<p>做打印机服务的话，就需要传递数据（在 SvcInit 方法的死循环中），可以通过管道（网络通讯），其它进程打开管道，往管道中写入数据，这边接受管道的数据并做处理。</p>
<p>在服务创建成功的时候就创建一个管道。进程间的相互通讯，可以通过协议（规定）来进行通讯。</p>
<p>服务是操作系统创建后台进程的一种方式。</p>
<p>一般做服务程序都是大型软件做的事情，自己/个人做的服务可用来监听一些本地文件的变化等。</p>
<h3 id="静态库动态库"><a href="#静态库动态库" class="headerlink" title="静态库动态库"></a>静态库动态库</h3><p>做dll要考虑通用性，使用的数据类型要通用。</p>
<p>在共享Dll中使用MFC，可以使用CString，不需要添加DllMain， MFC中写过DllMain。</p>
<p>MFC导出类的全局变量不能动态使用，</p>
<h4 id="动态使用"><a href="#动态使用" class="headerlink" title="动态使用"></a>动态使用</h4><p>动态使用获取的是全局变量的地址，<br>通过LoadLibrary ，GetProcAddress 获取导出变量的地址，通过函数指针指向该导出函数的地址，通过去内容就可以取出地址上的数据。</p>
<h4 id="静态使用"><a href="#静态使用" class="headerlink" title="静态使用"></a>静态使用</h4><p>在需要使用的程序中，包含.lib文件</p>
<p>静态使用的时候，需要使用的dll中变量的前面添加 __declspec(dllimport)关键字，将其声明为导出的，导出字符串也是如此。导出变量的类型需要自己去解析。</p>
<p>动态使用获取到的是指针，静态使用获取到的是对象.</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;../MyDll/debug/MyDll.lib&quot;</span>)</span><br><br>__declspec(dllimport) <span class="hljs-keyword">int</span> g_number;<br>__declspec(dllimport) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> g_cs;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//动态使用</span><br>  HMODULE hDll = LoadLibrary(<span class="hljs-string">&quot;MyDll.dll&quot;</span>);<br>  <span class="hljs-keyword">int</span> *pNum = (<span class="hljs-keyword">int</span>*)GetProcAddress(hDll, <span class="hljs-string">&quot;g_number&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_number=%d\n&quot;</span>, *pNum);<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> *pString = (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>*)GetProcAddress(hDll, <span class="hljs-string">&quot;g_cs&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_cs=%s\n&quot;</span>, pString-&gt;c_str());<br><br>  <span class="hljs-comment">//静态使用</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_number=%d\n&quot;</span>, g_number);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_cs=%s\n&quot;</span>, g_cs.c_str());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="dll劫持"><a href="#dll劫持" class="headerlink" title="dll劫持"></a>dll劫持</h3><p>根据dll的搜索路径去优先劫持对应的.dll。</p>
<blockquote>
<p>Dll搜索路径：1.遍历系统目录  2.当前目录   3.遍历环境变量  version.dll（系统的可以劫持）</p>
</blockquote>
<p>C C++ 命名粉碎（了解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C语言的调用约定（在链接的时候会检查）</span><br><span class="hljs-comment">//_fun1(编译后，导出函数的类型)</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">//_fun1@0 (编译后，导出函数的类型)</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> __stdcall <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// C++的调用约定以?开头包含作用域参数类型调用约定等</span><br></code></pre></td></tr></table></figure>

<p>extern “C”  – 会以C语言的名称粉碎将函数名进行粉碎，使用dll是导出函数，变量等不添加extern “C”，会以C++的调用名称粉碎对导出函数名进行粉碎。</p>
<h3 id="mfc-dll-ini-注册表"><a href="#mfc-dll-ini-注册表" class="headerlink" title="mfc dll .ini 注册表"></a>mfc dll .ini 注册表</h3><p>添加注册表的使用注意权限问题，使用 MFC dll 的时候注意模块状态问题（需要切换模块状态）。</p>
<p>MFC 共享 dll MFC框架的代码，动态链接进来。<br>静态链接（可以看源码），没有dll，MFC框架的代码，直接用静态库链接进来。</p>
<h3 id="进程-进程模块线程窗口遍历"><a href="#进程-进程模块线程窗口遍历" class="headerlink" title="进程 进程模块线程窗口遍历"></a>进程 进程模块线程窗口遍历</h3><p>纯API的调用</p>
<p>遍历堆卡 在遍历的时候申请了内存（造成递归 ） // TODO</p>
<h3 id="进程间的操作"><a href="#进程间的操作" class="headerlink" title="进程间的操作"></a>进程间的操作</h3><p>读写进程内存等（依赖于打开进程）<br>ReadProcessMemory<br>WriteProcessMemory<br>OpenProcess (注：权限问题)<br>OpenThread – 打开线程<br>TerminateProcess – 终止指定的进程<br>TerminateThread – 终止指定的线程</p>
<p>DuplicateHandle – 将一个句柄拷贝到另一个进程中（支持的句柄较多），可以跨进程拷贝（比较麻烦），同一个进程拷贝句柄比较方便。</p>
<p>每个线程可以给一个句柄值，句柄值可以不一样，但是其操控的是同一个东西。因此可以没创建一个线程就拷贝一个句柄值。通过句柄值去操作的都是同一个东西。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle#remarks">多线成同步示例</a></p>
<h3 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h3><ol>
<li>WM_COPYDATA</li>
<li>共享dll – 需要死循环的去读数据</li>
<li>内存共享(文件映射）– 需要死循环的去读数据</li>
</ol>
<p>效率并不高，需要死循环的去读数据，线程同步的几种方法进行通讯效率就会比进程间的通讯的效率高。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>临界区，内存锁（自加锁，自减锁，交换锁） – 不能跨进程通</p>
<p>互斥体，事件对象，信号量（通知机制） – 可以跨进程通讯 </p>
<p>大文件映射的时候，操作系统不会将整个大文件映射到内存，一段一段的文件进程映射。<br>MapViewOfFile – 将文件的视图映射到调用进程的地址空间中。</p>
<h3 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><p>计算API地址</p>
<p>API 函数在模块中的偏移：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">HMODULE hDll = GetModuleHandle(<span class="hljs-string">&quot;user32.dll&quot;</span>); <span class="hljs-comment">//00400000</span><br>PVOID pMessageBoxA = GetProcAddress(hDll, <span class="hljs-string">&quot;MessageBoxA&quot;</span>); <span class="hljs-comment">//00401000</span><br>PVOID pMessageBoxA = MessageBoxA;<br><span class="hljs-keyword">int</span> nOffset = (<span class="hljs-keyword">int</span>)pMessageBoxA - (<span class="hljs-keyword">int</span>)hDll; <span class="hljs-comment">//1000</span><br></code></pre></td></tr></table></figure>

<p>当不能保证对方进程加载模块的基址和自己进程模块的基址一样的时候，就需要通过下面的方式计算出对应的模块基址（为了保险起见每次插入dll的时候，都算一下模块的基址）：</p>
<p> 计算对象进程API地址<br> 本地API地址 - 获取本地模块基址 = 本地偏移<br> 获取远程模块基址 + 本地偏移 = 远程API地址</p>
<p> 代码示例：<br> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">HMODULE hDll = GetModuleHandle(<span class="hljs-string">&quot;user32.dll&quot;</span>); <span class="hljs-comment">// 00400000</span><br>PVOID pMessageBoxA = GetProcAddress(hDll, <span class="hljs-string">&quot;MessageBoxA&quot;</span>); <span class="hljs-comment">// 00401000</span><br><span class="hljs-comment">//PVOID pMessageBoxA = MessageBoxA;</span><br><span class="hljs-keyword">int</span> nOffset = (<span class="hljs-keyword">int</span>)pMessageBoxA - (<span class="hljs-keyword">int</span>)hDll; <span class="hljs-comment">// 1000</span><br><br><span class="hljs-comment">//获取对方模块基址</span><br>HMODULE hRemoteDll = (HMODULE)<span class="hljs-number">0x00500000</span>; <span class="hljs-comment">//user32.dll GetModuleHandleEx(hProcess, &quot;kernel32.dll&quot;);</span><br>PVOID pRemoteMessageBoxA = (PVOID)((<span class="hljs-keyword">int</span>)hRemoteDll + nOffset); <span class="hljs-comment">// 0x00501000</span><br><span class="hljs-comment">//创建远程线程，当目标进程没有指定的系统dll的时候，通过LoadLibrary帮其加载一份</span><br><span class="hljs-comment">//CreateRemoteThread(LoadLibrary, &quot;user32.dll&quot;);  // 系统加载的dll 1.ntdll.dll 2.kernel32.dll</span><br><span class="hljs-comment">//CreateRemoteThread(pRemoteMessageBoxA);         // 算过模块基址</span><br><span class="hljs-comment">//CreateRemoteThread(MessageBoxA);                // 没有算模块基址，不一定成功</span><br></code></pre></td></tr></table></figure></p>
<h3 id="Hook（钩子）"><a href="#Hook（钩子）" class="headerlink" title="Hook（钩子）"></a>Hook（钩子）</h3><h4 id="Hook-指定窗口"><a href="#Hook-指定窗口" class="headerlink" title="Hook 指定窗口"></a>Hook 指定窗口</h4><p>需要安装全局钩子</p>
<p>设置钩子的时候，通过FindWindow获取窗口句柄，通过获取到窗口句柄，使用 GetWindowThreadProcessId 获取指定窗口的线程ID，将获取到的线程ID传递给SetWindowsHookEx的最后一个参数使用。</p>
<p>一个线程可以有多个窗口，一个窗口只能有一个线程。</p>
<p>获取焦点窗口API – GetFocus</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">KeyboardProc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> szBuff[MAXBYTE];<br>  wsprintf(szBuff, <span class="hljs-string">&quot;[Test] KeyboardProc %c&quot;</span>, wParam);<br>  OutputDebugString(szBuff);<br><br>  <span class="hljs-keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SetHook</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 获取指定窗口句柄</span><br>  HWND hWnd = FindWindow(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;计算器&quot;</span>);<br>  <span class="hljs-comment">// 根据窗口句柄获取进程PID</span><br>  DWORD dwTID = GetWindowThreadProcessId(hWnd, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">// 根据进程PID, Hook 指定窗口</span><br>  g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, g_hModule, dwTID);<br>  <span class="hljs-keyword">if</span> (g_hHook != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br></code></pre></td></tr></table></figure>

<p>使用ToAscii获取按键的大小写：</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Windows.h&quot;</span></span><br><br>HHOOK g_hHook;<br>HMODULE g_hModule;<br><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-function"><span class="hljs-params">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-function"><span class="hljs-params">                       LPVOID lpReserved</span></span><br><span class="hljs-function"><span class="hljs-params">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    g_hModule = hModule;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>      ::MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;51ASM&quot;</span>, <span class="hljs-string">&quot;51ASM&quot;</span>, MB_OK);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">KeyboardProc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>  PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;<br><br>  <span class="hljs-keyword">char</span> szBuf[MAXBYTE];<br>  BYTE szStatus[<span class="hljs-number">256</span>];<br>  WORD key = <span class="hljs-number">0</span>;<br> <br><br>  <span class="hljs-keyword">if</span> (p-&gt;vkCode &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; p-&gt;vkCode &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>  &#123;<br>    GetKeyboardState(szStatus);	<span class="hljs-comment">// 获取键盘状态</span><br>    ToAscii(p-&gt;vkCode, p-&gt;scanCode, szStatus, &amp;key, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  wsprintf(szBuf, <span class="hljs-string">&quot;[51asm] KeyboardProc %c&quot;</span>, key);<br>  OutputDebugString(szBuf);<br><br>  <span class="hljs-keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SetHook</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  HWND hWnd = FindWindow(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;计算器&quot;</span>);<br>  DWORD dwTID = GetWindowThreadProcessId(hWnd, <span class="hljs-literal">NULL</span>);<br>  g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, g_hModule, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (g_hHook != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UnSetHook</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> UnhookWindowsHookEx(g_hHook);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Windows编程总结</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现C语言的预处理、编译和链接</title>
    <url>/posts/fc67ec64/</url>
    <content><![CDATA[<p>手动实现代码的预处理，编译，链接。 <a id="more"></a></p>
<h3 id="编写示例代码"><a href="#编写示例代码" class="headerlink" title="编写示例代码"></a>编写示例代码</h3><p>作为程序员我们需要了解我们编写的源程序是如何成为可执行文件，不能只会使用集成开发环境来完成这个过程。下面我就手动实现一下C语言的预处理、编译和链接这三个过程。</p>
<p>先用记事本写下下面几行代码并保存到计算机的磁盘内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//注意文件后缀格式，例如：main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\r\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们需要单击我们windows系统左下角的<code>开始</code>按钮，并找到<code>Visual Studio 2019</code>程序组内的<code>eveloper Command Prompt for VS 2019</code>程序，然后鼠标单击打开，并进入到我们刚才保存的<code>.cpp</code>文件夹内，如下图所示：<br><img src="1.png"></p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>可以理解成，编译之前对源文件进行简单加工的过程，在<code>eveloper Command Prompt for VS 2019</code>中执行先下面的命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//保存main.cpp的文件夹内会生成一个mian_new.cpp的文件</span><br>cl /EP mian.cpp &gt;mian_new.cpp<br></code></pre></td></tr></table></figure>
<p><img src="2.png"></p>
<p>可以看出新生成文件的大小要比源文件大许多，这是因为新的文件引入了头文件<br>的内容，并进行了其他的处理。我们可以打开新生成的文件查看下。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>这个过程就是将我们刚才对源文件进行预处理后生成的新文件进行编译，使其生成<code>目标文件</code>，在<code>eveloper Command Prompt for VS 2019</code>中执行先下面的命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//执行完，会生成两个文件，.asm和.obj文件</span><br>cl /FAs /c main_new.cpp<br></code></pre></td></tr></table></figure>
<p><img src="3.png"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>此时，生成的这三个文件还不能运行，我们还需要将函数库的二进制代码与目标文件合并到一起，形成一个可执行文件。<br>在<code>eveloper Command Prompt for VS 2019</code>中执行先下面的命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">link main_new.obj<br><span class="hljs-comment">//执行完该命令会在该文件夹内生成一个可执行文件</span><br></code></pre></td></tr></table></figure>
<p><img src="4.png"></p>
<p>最后在<code>eveloper Command Prompt for VS 2019</code>中执行先下面的命令就可以运行该程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">main_new<br></code></pre></td></tr></table></figure>

<p>运行结果：<br><img src="5.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>手动实现C语言的预处理、编译和链接</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的创建以及线程间的通信</title>
    <url>/posts/8a662d26/</url>
    <content><![CDATA[<p>Windows下线程的创建及使用。<a id="more"></a></p>
<p>判断管道内是否有数据API –&gt; PeekNamedPipe。<br>进程间的通讯（Inter-Process Communication –&gt; IPC） –&gt; 指至少两个进程或线程间传送数据或信号的一些技术或方法。</p>
<h3 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h3><p>进程（60年代）<br>线程（80年代）–&gt; 为每个程序分配单独的空间来运行程序</p>
<blockquote>
<p>为了解决进程的局限性</p>
</blockquote>
<p>每创建一个进程，系统都会为其分配空间，好多软件都是一个主进程外加好多子进程，子进程过多会耗费系统资源。创建进程的开销比较大。进程间的通讯也会占用系统资源。</p>
<blockquote>
<p>早期Linux解决多进程间资源的耗费：<br>将代码放置在同一个进程中，使其内存（代码）共享，供多个进程使用，可以解决进程间通讯的问题</p>
</blockquote>
<p>代码区 –&gt; 可以共享<br>数据区 –&gt; 可以共享<br>栈 –&gt; 不可以共享（进程使用的数据使用栈会导致数据出错）<br>堆 –&gt; 可以共享<br>为此，操作系统提供一个机制 ，栈不共享，剩下的内存进行共享。由于内存共享，通过全局变量就可以今进行线程间的通讯问题。不在需要进程间的通讯机制。</p>
<h4 id="线程-–-gt-轻量级的进程"><a href="#线程-–-gt-轻量级的进程" class="headerlink" title="线程 –&gt; 轻量级的进程"></a>线程 –&gt; 轻量级的进程</h4><h5 id="线程进程的差异"><a href="#线程进程的差异" class="headerlink" title="线程进程的差异"></a>线程进程的差异</h5><p>CPU 分配时间片以进程为单位，一个进程跑完，在去跑另一个进程。<br>线程 –&gt; 轻量级的进程（同样需要消耗系统资源，消耗的资源要比进程少），</p>
<blockquote>
<p>每个进程可以创建多个线程，创建的线程都属于这个进程，除了栈，其它内存都共享，CPU在调度的时候不在以进程为单位，会以线程为单位（CPU创建的时间片以线程为单位，不用在创建进程消耗更大的资源）。属于同一个进程的线程其内存是共享的，反之，不共享。每个线程单独跑。<br>创建线程所消耗的资源要比创建进程所消耗的资源要少。创建一个进程可以使用线程来解决我们所需要的问题。</p>
</blockquote>
<blockquote>
<p>创建线程的时候为其提供一个函数地址，这个线程就只负责这个函数地址上代码，线程单独跑一个模块。<br>多线程同属于一个进程，不需要通讯，可以通过全局变量进程数据的读取，其内部内存共享。</p>
</blockquote>
<p>多进程的作用：内存隔离</p>
<p>耦合性强的两个模块适合放在同一个进程中。</p>
<h5 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h5><p>由CPU进程操控，一个线程一个线程的去跑，每个线程跑完后，会保存其<strong>线程上下文</strong>（硬件环境（CPU的寄存器环境））<br>线程1：1<br>线程2：2</p>
<p>超线程（一种更快速的切换线程环境）：将一个房间放入两张床，线程1来的时候，住床1，线程2来的时候，住床2，切换线程的时候，不用再保存线程上下文，速度上也提高了不少。<br>一种更快速的切换线程环境（线程环境不需要保存和恢复）</p>
<p>多核CPU要比超线程还要快。</p>
<h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><p>创建线程API –&gt; CretaeThread</p>
<p>创建一个进程最低有一个线程（主线程）因为现在CPU是以线程为单位的，通过主线程创建的线程称之为其子线程。</p>
<p>程序线程的分工设计：<br>主线程只负责UI<br>子线程去实现功能</p>
<p>创建线程的参数：</p>
<ul>
<li>参数1：返回的句柄是否可以被子进程继承，一般创建线程不继承</li>
<li>参数2：栈的大小（在同一个进程中，每个线程在内存中使用的是同一个栈），当创建一个线程的是否，就要为该线程向系统申请一个指定大小的栈空间，防止和其它栈搞混乱。栈空间大小按需求向系统申请，大小单位为 <strong>页</strong></li>
<li>参数3：函数地址（线程过程函数（工作线程））–&gt; 创建的线程负责跑的功能模块</li>
<li>参数4：会将该参数传递给线程的过程函数</li>
<li>参数5：线程的标志（是否挂起）线程没有工作任务的时候，可以将其挂起（CREATE_SUSPENDED），挂起的线程，系统不为其分配时间片，为线程马上分配时间片填 0 即可（过程函数不会立马执行，线程会排队等待处理）。Widnows系统中的线程有VIP之分（线程优先级）。线程具有线程优先级（动态的，系统会根据情况确定哪个线程先跑，线程调度），优先级高的线程优先执行，优先分配时间片。</li>
<li>参数6：返回创建的线程ID 类型可以为 DWORD，不需要可以给空</li>
</ul>
<p>编程来源于生活，生活中的相关问题都是经过验证的。</p>
<p>创建线程也是有上线的：最大线程数 –&gt; 65535</p>
<p>主线程结束（系统认为进程结束），子线程不管有没有执行完都会停止执行（强制结束）。线程是依赖于进程的，进程结束，线程也就没必要在继续执行。</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">// 线程间数据共享可以通过全局变量</span><br><span class="hljs-keyword">int</span> g_nNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> g_Flag = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 工作线程</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">WorkThread</span><span class="hljs-params">(LPVOID lpParameter)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//while (true)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;talk... :%d\r\n&quot;</span>, g_nNum);<br>    Sleep(<span class="hljs-number">1000</span>);<br>  &#125;<br><br>  g_Flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    代码区 --&gt; 共享</span><br><span class="hljs-comment">    数据区 --&gt; 共享</span><br><span class="hljs-comment">    栈 --&gt; 不共享</span><br><span class="hljs-comment">    堆 --&gt; 共享</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    线程  超线程</span><br><span class="hljs-comment">    主线程)   子线程   子线程</span><br><span class="hljs-comment">    CREATE_SUSPENDED 挂起</span><br><span class="hljs-comment">    线程优先级  线程调度</span><br><span class="hljs-comment">    纤程</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-comment">// 创建一个线程</span><br>  DWORD wdThreadID;<br>  HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, WorkThread, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;wdThreadID);<br><br>  <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread Error!\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread hThread = %d wdThreadID = %d\r\n&quot;</span>, hThread, wdThreadID);<br>  <span class="hljs-comment">//while (true)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;attck...&quot;</span>);<br>    Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 让出时间片</span><br>    g_nNum += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_nNum = %d\r\n&quot;</span>, g_nNum);<br><br>  <span class="hljs-comment">// 线程间需要进程交互</span><br>  <span class="hljs-comment">//system(&quot;pause&quot;);</span><br>  <span class="hljs-keyword">while</span> (!g_Flag);    <span class="hljs-comment">// 当子线程代码执行完毕，才允许进程结束</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//主线程结束  进程结束(强制结束子线程)</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="线程间的交互"><a href="#线程间的交互" class="headerlink" title="线程间的交互"></a>线程间的交互</h4><h5 id="线程的回调函数的参数"><a href="#线程的回调函数的参数" class="headerlink" title="线程的回调函数的参数"></a>线程的回调函数的参数</h5><p>上面的示例，当需求发生改变的时候，比如需要打两只怪，那么就需要再次定义一个线程以及一个回调函数，这样写代码，会造成线程1以和线程2的代码类似，出现代码冗余现象。当创建100个，1000个线程的时候，这种方法显然不是一种好的解决办法。</p>
<p>这个时候我们就需要用到线程的回调函数的参数来解决这个问题：</p>
<p>获取线程句柄 –&gt; GetCurrentThread<br>获取线程ID –&gt; GetCurrentThreadId</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 工作线程</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">WorkThread</span><span class="hljs-params">(LPVOID lpParameter)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ThreadHandle: %p, ThreadID: %04d, attck...master: %d\r\n&quot;</span>, <br>      GetCurrentThread(),   <span class="hljs-comment">// 获取进程句柄</span><br>      GetCurrentThreadId(), <span class="hljs-comment">// 获取进程ID</span><br>      lpParameter);<br>    Sleep(<span class="hljs-number">1000</span>);<br>  &#125;<br>  g_Flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 创建线程数组 --&gt; 两个线程</span><br>  DWORD wdThreadID[<span class="hljs-number">2</span>];<br>  HANDLE hThread[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>  &#123;<br>    hThread[i] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, WorkThread, (LPVOID)(i+<span class="hljs-number">1</span>), <span class="hljs-number">0</span>, &amp;wdThreadID[i]);<br>    <span class="hljs-keyword">if</span> (hThread[i] == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread %d Error!\r\n&quot;</span>, wdThreadID[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread hThread = %d wdThreadID = %d\r\n&quot;</span>, hThread, wdThreadID);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (!g_Flag);    <span class="hljs-comment">// 当子线程代码执行完毕，才允许进程结束</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;           <span class="hljs-comment">// 主线程结束  进程结束(强制结束子线程)</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h5 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h5><blockquote>
<p>WaitForSingleObject –&gt; 等待，直到指定的进程等待用户输入而没有输入挂起，或者直到超时间隔结束<br>会阻塞，等待线程结束。（无线等待 INFINITE） –&gt; 只等待指定的线程</p>
</blockquote>
<blockquote>
<p>WaitForMultipleObjects –&gt; 等待所有线程结束</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 创建一个线程</span><br>DWORD wdThreadID[<span class="hljs-number">2</span>];<br>HANDLE hThread[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br>  hThread[i] = CreateThread(<span class="hljs-literal">NULL</span>,<br>    <span class="hljs-number">0</span>,<br>    i == <span class="hljs-number">1</span> ? WorkThread2 : WorkThread,<br>    (LPVOID)(i+<span class="hljs-number">1</span>),<br>    <span class="hljs-number">0</span>,<br>    &amp;wdThreadID[i]);<br>  <span class="hljs-keyword">if</span> (hThread[i] == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread %d Error!\r\n&quot;</span>, wdThreadID[i]);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateThread hThread = %d wdThreadID = %d\r\n&quot;</span>, hThread, wdThreadID);<br>&#125;<br><span class="hljs-comment">// 等待线程结束  阻塞 </span><br><span class="hljs-comment">//WaitForSingleObject(hThread[0], 1000);  // 线程不结束，挂起等待</span><br><span class="hljs-comment">//WaitForSingleObject(hThread[1], 1000);</span><br>WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, TRUE, INFINITE);<br></code></pre></td></tr></table></figure>

<h5 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h5><blockquote>
<p><strong>TerminateThread</strong> –&gt; 终止一个线程(强制结束)，参数1为需要结束的线程句柄，参数2为需要结束的线程回调函数的返回值。(<strong>不推荐使用</strong>，强制结束的线程可能存在还没有完成的事请，比如正在保存文件）</p>
</blockquote>
<p>可以强制结束别的程序的的线程，通过快照遍历得到指定线程的PID</p>
<p>结束线程比较合适的时机是在线程回调函数返回值之前进程。自己在回调函数中做标记来决定合适结束线程。</p>
<h5 id="线程退出码"><a href="#线程退出码" class="headerlink" title="线程退出码"></a>线程退出码</h5><blockquote>
<p>ExitThread –&gt; 哪个线程调用这个函数，就自动结束自己。参数 –&gt; 此线程的退出代码<br>主线程使用这个函数也会结束自己</p>
</blockquote>
<p>GetExitCodeThread –&gt; 检索指定线程的终止状态</p>
<h5 id="线程相关API"><a href="#线程相关API" class="headerlink" title="线程相关API"></a>线程相关API</h5><p>GetThreadPriority –&gt; 获取指定线程的优先级（返回获取到的优先级）<br>SetThreadPriority –&gt; 设置指定线程的优先级<br>SetThreadAffinityMask –&gt; 设置线程在哪核CPU上跑<br>SuspendThread –&gt; 挂起指定的线程（创建线程的时候也可以将线程挂起）<br>ResumeThread –&gt; 减少线程的挂起计数（将指定挂起的线程恢复）</p>
<p>线程的挂起是用了引用计数，挂起几次就需要恢复几次，对应的线程才会运行</p>
<p>纤程：<br>一个进程可以有多个线程，一个线程可以有多个纤程<br>作用：可以自己控制时间片，自己管理，以及什么时候切换</p>
<p>是为了解决别的操作系统多线程代码可以移植到Windows上，能使用线程就不要去使用纤程</p>
<p>线程存在问题：资源竞争</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线程的创建以及线程间的通信</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本风扇清灰</title>
    <url>/posts/8740e7fd/</url>
    <content><![CDATA[<p>给笔记本清理灰尘。<a id="more"></a></p>
<p>中午吃完午饭，想了想17年买的笔记本到现在还没清理过散热风扇，里面的灰肯定不会少，所以我打算盘它，给本子的散热风扇清清灰。我记得我的笔记本去年年初的时候更换过电池，也是自己动手更换的，挺简单的。如果有同学们看到我写的这篇blog的话，在这里呢我给大家说下，在我们玩笔记本的时候尽量插着电源玩，因为这样是降低笔记本电池损耗率最直接最简单的方法，亲测有效。为什么呢？文章最后再给大家说吧，我们还是先来拆机吧。</p>
<ul>
<li>需要先找把合适的工具，然后拧下笔记本螺丝打开后盖，打开后拔掉电池的电源以及散热风扇的电源<br><img src="computer1.jpg"></li>
<li>接着需要把风扇上面的螺丝以及压在显卡上的散热铜管上的螺丝全部拧掉<br><img src="computer2.jpg"></li>
<li>卸下风扇，嗯……不慌毕竟两年多没清理了,这点灰尘不算什么<br><img src="computer3.jpg"></li>
<li>取下风扇就可以盘它了，我是先用的牙签卷纸先把上面的灰尘给擦掉<br><img src="computer4.jpg"></li>
<li>接着用酒精给风扇来了个全身沐浴，哈哈…<br><img src="computer5.jpg"></li>
<li>清理完后就可以把它们放回到自己原来的岗位上了<br><img src="computer6.jpg"></li>
<li>自我感觉还不错哦<br><img src="computer7.jpg"></li>
</ul>
<p>在这里呢给大家说简单说几句吧，现在的笔记本无非就是游戏本和轻薄本，目前轻薄本呢分支持pd充电协议和不支持pd充电协议这两种。支持pd协议的呢，插着电源玩准没错，因为充电头比我们聪明，嘿嘿，不支持pd协议的呢，插着电源也准没错，因为计算机也比我们聪明。即使啥也不干，电池也会损耗，其实我们也可以一个月把计算机的电池放个一两次电，怎么放呢，就是把计算机电池充满，然后拔掉电源，什么也不干，让计算机开着机进行放电操作（也就是我们所说的待机）。然后要是想看自己笔记本电池的损耗程度，可以参考下面的做法：<br>点击Windows左下角的Windows图标输入cmd，然后右击以管理员身份打开输入下面的命令:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">powercfg /batteryreport<br></code></pre></td></tr></table></figure>

<p>之后打开输入命令后cmd弹出的指定目录进行查看即可。<br><img src="20200218181014.png"></p>
]]></content>
      <categories>
        <category>手动实践</category>
      </categories>
      <tags>
        <tag>笔记本风扇清灰</tag>
      </tags>
  </entry>
  <entry>
    <title>进制间的转换</title>
    <url>/posts/24d10e2f/</url>
    <content><![CDATA[<p>进制计数法的表现方式以及进制之间相互的转换。</p>
<a id="more"></a>

<h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>指二进制计数系统，基于2的幂，用数字”0 和 1”表示。</p>
<p><strong>逢2进一</strong><br>二进制数第一位上的1 相当于十进制第一位上的1<br>二进制数第二位上的1 相当于十进制第二位上的2<br>二进制数第三位上的1 相当于十进制第三位上的4<br>二进制数第四位上的1 相当于十进制第四位上的8<br>二进制数第五位上的1 相当于十进制第五位上的16<br>···</p>
<p>二进制数 <strong>1011</strong> 转换为十进制数如下：<br>1*2^2+ 0*2^2 + 1*2^1 + 1*2^0 = 11</p>
<p><img src="1.png"></p>
<h4 id="八进制-octal"><a href="#八进制-octal" class="headerlink" title="八进制(octal)"></a>八进制(octal)</h4><p>指八进制计数系统，基于8的幂，用数字”0~7”表示。</p>
<p><strong>逢8进一</strong><br>八进制数第一位上的1 相当于十进制第一位上的1<br>八进制数第二位上的1 相当于十进制第二位上的8<br>八进制数第三位上的1 相当于十进制第三位上的64<br>八进制数第四位上的1 相当于十进制第四位上的512<br>···</p>
<p>八进制数 <strong>451</strong> 转换为十进制数如下：<br>4*8^2 + 5*8^1 +1*8^0 = 297</p>
<p><strong>八进制转换二进制</strong></p>
<p>每个八进制位会对应3个二进制位，如下表：</p>
<table>
<thead>
<tr>
<th>八进制</th>
<th>等价的二进制</th>
<th>八进制</th>
<th>等价的二进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>4</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>6</td>
<td>110</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>7</td>
<td>111</td>
</tr>
</tbody></table>
<p>例如：八进制数 <strong>166</strong> 的二进制数为： <strong>1 110 110</strong></p>
<p>八进制 <strong>166</strong> 中的 <strong>1、6、6</strong> 分别对应二进制数 <strong>001、110、110</strong></p>
<p>注意：在将八进制转化为二进制后，二进制中的 <strong>0</strong> 不能省略。</p>
<h4 id="十六进制-hex"><a href="#十六进制-hex" class="headerlink" title="十六进制(hex)"></a>十六进制(hex)</h4><p>指十六进制计数系统，基于16的幂，用数字”0 到 9”以及大写字母”A 到 F 或者 a 到 f”(A 到 F表示数字10 到 15)表示。</p>
<p><strong>逢16进一</strong></p>
<p>十六进制数 <strong>0xA9F6</strong> 转换为十进制数如下：<br>10*16^3 + 9*16^2 + 15*16^1 + 6*16^0 = 43510</p>
<p><strong>十六进制转换成二进制</strong></p>
<p>每个十六进制位都对应一个4个二进制位，两个十六进制数刚好对应8位字节，如下表：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>十六进制</th>
<th>等价二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>等价二进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>10</td>
<td>A</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>11</td>
<td>B</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>12</td>
<td>C</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>13</td>
<td>D</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>14</td>
<td>E</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>15</td>
<td>F</td>
<td>1111</td>
</tr>
</tbody></table>
<p>十六进制数 <strong>0xA9</strong> 可转换成二进制数： <strong>1010 1001</strong>，同理二进制数 <strong>0111 1111</strong> 可转换十六进制数： <strong>0x7F</strong></p>
<h3 id="计算机是处理信息的机器"><a href="#计算机是处理信息的机器" class="headerlink" title="计算机是处理信息的机器"></a>计算机是处理信息的机器</h3><p>输入数据–&gt;处理数据–&gt;输出数据–&gt;(长期存储数据)</p>
<h3 id="在内存中存储数据的基本方法"><a href="#在内存中存储数据的基本方法" class="headerlink" title="在内存中存储数据的基本方法"></a>在内存中存储数据的基本方法</h3><p>变量：在内存中一块被命名的内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 向系统申请一块内存空间，用于存储整型值，用名称x映射到这块空间。</span><br><span class="hljs-comment">// 如果在声明变量的时候没有赋初值，则变量的值是不确定的一个值。</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-comment">// 表达式的结果类型，取表达式中所有元素的最高级别(精度最高，范围最大)的数据类型</span><br><span class="hljs-keyword">float</span> f = <span class="hljs-number">1</span> / <span class="hljs-number">3.0</span>; <br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>进制间的转换</tag>
      </tags>
  </entry>
  <entry>
    <title>BOC外汇牌价项目实践</title>
    <url>/posts/bd6a3c41/</url>
    <content><![CDATA[<p>中国银行外汇牌价看板项目实现记录。</p>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>声明：本项目并没有进行非法用途，只是用来学习相应的知识的。</p>
<p>2020年3月9日科锐的预科班开始了，在 <strong>Tony He</strong> 老师半个月带领下，我最终完成了 <strong>BOC外汇牌价看板</strong> 这个小项目。<strong>Tony He</strong> 老师的讲课方式刷新了我的认知，可以说要比在校期间老师们的讲课方式效果上要好很多。在这半个月里，何老师以最终的小项目为目的，将所用到的知识点分成批次，每天给我们讲解一点所需的知识点，由浅入深，坚持每天练习所讲的知识点。经过这半个多月的学习，也将我之前学的相关<strong>C语言</strong>知识进一步等到了巩固，指针、文件操作等。记得 <strong>Tony He</strong> 老师的一句话：**”掌握了正确的学习程序设计的方法就是，从解决实际需求出发、带着问题学、急用先学，学以致用。当你在实践中遇到一个问题，就去寻找这个问题的答案，每次找到的答案帮助你解决一个实际的问题，然后又遇到一个新的问题，然后再解决它……你的学习就会变得非常有效，而且你学到的知识就是最实用、最急用的知识。”** 这句话讲的确实很对。</p>
<!--more-->

<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>由于最终的项目需要爬取BOC的实时数据，所以这一点也是最难的一点。由于是预科班，班上大多数师兄，基础都不是很好（当然也包括我），所用的程序接口都还不会写。考虑到这里 <strong>Tony He</strong> 老师就自己做了一个，供大家调用学习。</p>
<h4 id="项目所用到的知识点："><a href="#项目所用到的知识点：" class="headerlink" title="项目所用到的知识点："></a>项目所用到的知识点：</h4><ul>
<li>C 语言基础语言</li>
<li>C 语言指针</li>
<li>C 语言文件的操作（读取，存储）</li>
<li>C 语言结构体</li>
<li>C++ 类&amp;对象</li>
<li>C++ 类的封装</li>
<li>C++ 继承、构造函数、析构函数</li>
<li>EaxyX 图形库的简单使用</li>
</ul>
<h4 id="外汇牌价看板设计要求"><a href="#外汇牌价看板设计要求" class="headerlink" title="外汇牌价看板设计要求"></a>外汇牌价看板设计要求</h4><p>外汇牌价看板是一个基于C/S应用程序，用于显示中国银行实时外汇牌价。</p>
<h5 id="程序运行环境"><a href="#程序运行环境" class="headerlink" title="程序运行环境"></a>程序运行环境</h5><p>本系统运行与Windows操作系统（至少兼容Windows 10），程序工作时计算机应连接互联网。</p>
<h5 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h5><p>程序运行的窗口分辨率需要为 1280 * 720像素，运行效果如下图（注：图片来源于网络）：</p>
<p><img src="boc.png"></p>
<h5 id="程序功能说明"><a href="#程序功能说明" class="headerlink" title="程序功能说明"></a>程序功能说明</h5><ul>
<li><p>程序启动时，调用BOCRates接口库，取得牌价数据保存为磁盘文件，并按照上图的形式显示；</p>
</li>
<li><p>需要显示的外币种类包括：阿联酋迪拉姆、澳大利亚元、巴西里亚尔、加拿大元、瑞士法郎、丹麦克朗、欧元、英镑、港币、印尼卢比、印度卢比、日元、韩国元、澳门元、林吉特、挪威克朗、新西兰元、菲律宾比索、卢布、沙特里亚尔、瑞典克朗、新加坡元、泰国铢、土耳其里拉、新台币、美元、南非兰特，共计27种；</p>
</li>
<li><p>每页显示7种外汇牌价，一次显示一页，每页显示20秒后启动切换至下一页；（注：为便于调试可适当减少时间间隔）；</p>
</li>
<li><p>每10分钟从服务器重新获取一次最新的汇率数据并显示，在最左上角显示外汇更新时间。</p>
</li>
<li><p>当汇率接口服务器不能连接时，自动取出最后一次成功获取的汇率数据，并将其重新显示出来。</p>
</li>
</ul>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p>这里记录下我的功能实现过程</p>
<h4 id="整理所需的头文件"><a href="#整理所需的头文件" class="headerlink" title="整理所需的头文件"></a>整理所需的头文件</h4><p>新建一个头文件 <code>main.h</code>，将所用到的头文件都放在这一个文件内，然后再所需的文件内包含该头文件即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/BOCExchangeRate/BOCRates/BOCRates.h&gt;// 接口库头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/BOCExchangeRate/BOCRates/BOCRates.lib&quot;</span>)</span><br><br><span class="hljs-comment">// 信息头BITMAPHEADER，也是一个结构体，其定义如下：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapHeader</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">// char Tag[2];// 用来存储BMP格式图像的前两个字节字母</span><br>  <span class="hljs-keyword">long</span> Size;        <span class="hljs-comment">// 文件大小</span><br>  <span class="hljs-keyword">short</span> Reserved1;  <span class="hljs-comment">// 保留字，不考虑</span><br>  <span class="hljs-keyword">short</span> Reserved2;  <span class="hljs-comment">// 保留字，同上</span><br>  <span class="hljs-keyword">long</span> OffBits;     <span class="hljs-comment">// 实际位图数据的偏移字节数，即前三个部分长度之和</span><br>&#125;BIT_MAP_HEADER;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapInfo</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">long</span>   Size;      <span class="hljs-comment">// 指定此结构体的长度，为40   </span><br>  <span class="hljs-keyword">long</span>   Width;     <span class="hljs-comment">// 位图宽   </span><br>  <span class="hljs-keyword">long</span>   Height;    <span class="hljs-comment">// 位图高   </span><br>  <span class="hljs-keyword">short</span>  Planes;    <span class="hljs-comment">// 平面数，为1   </span><br>  <span class="hljs-keyword">short</span>  BitCount;  <span class="hljs-comment">// 采用颜色位数，可以是1(单)，2(8色)，4(16色)，8(255色)，16，24，新的可以是32   </span><br>  <span class="hljs-keyword">long</span>   Compression; <span class="hljs-comment">// 压缩方式，可以是0，1，2，其中0表示不压缩   </span><br>  <span class="hljs-keyword">long</span>   SizeImage;   <span class="hljs-comment">// 实际位图数据占用的字节数   </span><br>  <span class="hljs-keyword">long</span>   XPelsPerMeter; <span class="hljs-comment">// X方向分辨率   </span><br>  <span class="hljs-keyword">long</span>   YPelsPerMeter; <span class="hljs-comment">// Y方向分辨率   </span><br>  <span class="hljs-keyword">long</span>   ClrUsed;       <span class="hljs-comment">// 使用的颜色数，如果为0，则表示默认值(2^颜色位数)   </span><br>  <span class="hljs-keyword">long</span>   ClrImportant;  <span class="hljs-comment">// 重要颜色数，如果为0，则表示所有颜色都是重要的</span><br>&#125; BIT_MAP_INFO;<br></code></pre></td></tr></table></figure>
<h4 id="初始化绘图框"><a href="#初始化绘图框" class="headerlink" title="初始化绘图框"></a>初始化绘图框</h4><p>再这里新建了一个类，名为：<code>CExchange</code>，对应的头文件进行方法的声明，对应的 <code>.cpp</code> 文件用来方法的实现。</p>
<p><strong>CExchange.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CExchange</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showGraphic</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 初始化绘图框信息</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHorizonLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xSart, <span class="hljs-keyword">int</span> xEnd, COLORREF color)</span></span>;         <span class="hljs-comment">// 水平线</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawVerticalLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> yStart, <span class="hljs-keyword">int</span> yEnd, COLORREF color)</span></span>;       <span class="hljs-comment">// 垂直线</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, COLORREF color)</span></span>;<span class="hljs-comment">// 画框</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>CExchange.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CExchange.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CExchange::showGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  initgraph(<span class="hljs-number">1280</span>, <span class="hljs-number">720</span>); /初始化一个<span class="hljs-number">1280</span>*<span class="hljs-number">720</span>（像素）的绘图窗口<br>  setbkcolor(WHITE);<span class="hljs-comment">// 设置背景色</span><br>  cleardevice();    <span class="hljs-comment">// 清空绘图设备用当前背景色清空绘图设备，并将当前点移至 (0, 0)</span><br>  setcolor(BLACK);  <span class="hljs-comment">// 设置当前绘图框的前景色</span><br>  <span class="hljs-comment">// 指定位置输出标题</span><br>  outtextxy(<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;国家国旗&quot;</span>);<br>  outtextxy(<span class="hljs-number">190</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;货币名称&quot;</span>);<br>  outtextxy(<span class="hljs-number">320</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;货币代码&quot;</span>);<br>  outtextxy(<span class="hljs-number">450</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;现汇买入价&quot;</span>);<br>  outtextxy(<span class="hljs-number">590</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;现钞买入价&quot;</span>);<br>  outtextxy(<span class="hljs-number">730</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;现汇卖出价&quot;</span>);<br>  outtextxy(<span class="hljs-number">850</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;现钞卖出价&quot;</span>);<br>  outtextxy(<span class="hljs-number">970</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;中行折算价&quot;</span>);<br>  outtextxy(<span class="hljs-number">1090</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&quot;数据更新日期及时间&quot;</span>);<br>  <br>  outtextxy(<span class="hljs-number">560</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;BOC EXCHANGE RATE&quot;</span>);<br>  LOGFONT f;<br>  gettextstyle(&amp;f); <span class="hljs-comment">// 获取当前字体设置</span><br>  f.lfHeight = <span class="hljs-number">30</span>;  <span class="hljs-comment">// 设置字体高度为 30</span><br>  _tcscpy(f.lfFaceName, _T(<span class="hljs-string">&quot;黑体&quot;</span>)); <span class="hljs-comment">// 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数)</span><br>  f.lfQuality = ANTIALIASED_QUALITY; <span class="hljs-comment">// 设置输出效果为抗锯齿  </span><br>  settextstyle(&amp;f); <span class="hljs-comment">// 设置字体样式</span><br>  outtextxy(<span class="hljs-number">460</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;中国银行外汇(部分)牌价表&quot;</span>));<br>&#125;<br><span class="hljs-comment">// 水平线</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CExchange::drawHorizonLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xSart, <span class="hljs-keyword">int</span> xEnd, COLORREF color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = xSart; x &lt; xEnd; x++)<br>  &#123;<br>    putpixel(x, y, color);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 垂直线</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CExchange::drawVerticalLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> yStart, <span class="hljs-keyword">int</span> yEnd, COLORREF color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = yStart; y &lt; yEnd; y++)<br>  &#123;<br>    putpixel(x, y, color);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 画图形</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CExchange::displayBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, COLORREF color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = left; y &lt; height; y++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = top; x &lt; width; x++)<br>    &#123;<br>      drawVerticalLine(x, y, height, color);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="国旗图片及数据显示位置"><a href="#国旗图片及数据显示位置" class="headerlink" title="国旗图片及数据显示位置"></a>国旗图片及数据显示位置</h4><p>创建 <code>CBoxs</code> 类，用于实现国旗图片及数据的显示位置</p>
<p><strong>CBoxs.b声明对应方法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBoxs</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> _top;<br>  <span class="hljs-keyword">int</span> _left;<br>  <span class="hljs-keyword">int</span> _width;<br>  <span class="hljs-keyword">int</span> _height;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetImagesPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetImagesSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLeft</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>CBoxs.cpp对应方法的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CBoxs.h&quot;</span></span><br><span class="hljs-comment">// 用于显示国旗图片的位置</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CBoxs::SetImagesPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left)</span></span><br><span class="hljs-function"></span>&#123;<br>  _top = top;<br>  _left = left;<br>&#125;<br><span class="hljs-comment">// 显示国旗图片的大小</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CBoxs::SetImagesSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span><br><span class="hljs-function"></span>&#123;<br>  _width = width;<br>  _height = height;<br>&#125;<br><span class="hljs-comment">// 图片像素点的显示</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CBoxs::GetLeft</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> _left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CBoxs::GetTop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> _top;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="国旗图片的显示"><a href="#国旗图片的显示" class="headerlink" title="国旗图片的显示"></a>国旗图片的显示</h4><p>需要读取指定路径的 <code>.bmp</code> 图片文件，对读入的图片进行相应的处理。判断 <code>BMP</code> 文件是否打开成功，判断打开文件的字节大小是否大于20MB，大于20MB拒绝显示，国旗图片打开成功后，为其分配对应字节大小的内存空间，之后将对应的指针，指向 <code>BMP</code> 文件对应的信息头、偏移量、以及像素区域。</p>
<p>基于 <code>CBoxs</code> 父类，创建一个子类：<code>CPictureBoxs</code><br>对应的头文件 <code>CPictureBoxs.h</code> 为保存对应方法的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPictureBoxs</span> :</span> <span class="hljs-keyword">public</span> CBoxs<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">void</span>* _fileBuffer = <span class="hljs-literal">NULL</span>;             <span class="hljs-comment">// 分配内存，保存读取到的BMP文件</span><br>  BIT_MAP_HEADER* _bitMapHeader = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 指向第一个结构体</span><br>  BIT_MAP_INFO* _bitMapInfo = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// 执行第二个结构体，该结构体为BMP文件的信息头</span><br>  <span class="hljs-comment">// PaletteColor* _palette = NULL;</span><br>  <span class="hljs-keyword">void</span>* _pixelData = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 指向BMP文件的像素数据区</span><br>  <span class="hljs-comment">// COLORREF GetPixelColor(int x, int y); // 显示BMP文件</span><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LoadBMPFromFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ShowPicture</span><span class="hljs-params">()</span></span>;<br>  ~CPictureBoxs();<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><strong>CPictureBoxs.cpp 为 CPictureBoxs.h 内的方法实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CPictureBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-comment">// 析构函数,在类的实例被销毁的时候会自动执行该函数</span><br>CPictureBoxs::~CPictureBoxs()<br>&#123;<br>  <span class="hljs-keyword">if</span> (_fileBuffer != <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">free</span>(_fileBuffer);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 读入图片</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPictureBoxs::LoadBMPFromFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(fileName, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开失败\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">int</span> fileSize = filelength(fileno(fp));<br>    <span class="hljs-keyword">if</span> (fileSize &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该文件总字节数大于20MB，拒绝显示\r\n&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      _fileBuffer = <span class="hljs-built_in">malloc</span>(fileSize);<br>      <span class="hljs-keyword">if</span> (_fileBuffer == <span class="hljs-literal">NULL</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\r\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-comment">// 内存分配成功，读取文件</span><br>        fread(_fileBuffer, fileSize, <span class="hljs-number">1</span>, fp);<br>        <span class="hljs-comment">// 将_bitMapHeader指针指向位图的文件头，BIT_MAP_HEADER这个结构体的首地址</span><br>        _bitMapHeader = (BIT_MAP_HEADER*)(((<span class="hljs-keyword">char</span>*)(_fileBuffer)) + <span class="hljs-number">2</span>); <br>        <span class="hljs-comment">// 将_bitMapInfo指针指向位图的信息头，BIT_MAP_INFO这个结构体的首地址</span><br>        _bitMapInfo = (BIT_MAP_INFO*)(((<span class="hljs-keyword">char</span>*)(_fileBuffer)) + <span class="hljs-number">14</span>);<br>        <span class="hljs-comment">// 将_pixelData指针指向位图的实际数据区的首地址</span><br>        _pixelData = (<span class="hljs-keyword">char</span>*)_fileBuffer + _bitMapHeader-&gt;OffBits; <br>        fclose(fp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 遍历BMP图片所有像素点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPictureBoxs::ShowPicture</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> xStart = GetLeft();<br>  <span class="hljs-keyword">int</span> yStart = GetTop();<br>  <span class="hljs-keyword">char</span>* tags  = (<span class="hljs-keyword">char</span>*)_pixelData;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = yStart + _bitMapInfo-&gt;Height - <span class="hljs-number">1</span>; y &gt;= yStart; y--)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = xStart; x &lt;= xStart + _bitMapInfo-&gt;Width - <span class="hljs-number">1</span>; x++)<br>    &#123;<br>      putpixel(x, y, RGB(tags[<span class="hljs-number">2</span>], tags[<span class="hljs-number">1</span>], tags[<span class="hljs-number">0</span>]));<br>      tags += <span class="hljs-number">3</span>;<br>      <span class="hljs-comment">// 判断打开的BMP位图的宽度是否为4的倍数</span><br>      <span class="hljs-keyword">if</span> (_bitMapInfo-&gt;Width * <span class="hljs-number">3</span> % <span class="hljs-number">4</span> != <span class="hljs-number">0</span> &amp;&amp; x == _bitMapInfo-&gt;Height - <span class="hljs-number">1</span>)<br>      &#123;<br>        tags += <span class="hljs-number">4</span> - (_bitMapInfo-&gt;Width * <span class="hljs-number">3</span> % <span class="hljs-number">4</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数据的读取、保存磁盘、以及数据的分页显示"><a href="#数据的读取、保存磁盘、以及数据的分页显示" class="headerlink" title="数据的读取、保存磁盘、以及数据的分页显示"></a>数据的读取、保存磁盘、以及数据的分页显示</h4><p>基于 <code>CBoxs</code> 父类创建一个 <code>CRatesList</code> 子类<br>该类实现的方法有：</p>
<ul>
<li>程序运行从服务器获取数据</li>
<li>从服务器一次性获取最新的数据</li>
<li>返回从服务器获取的外汇牌价数量</li>
<li>将从服务器获取的外汇数据保存到指定磁盘文件内</li>
<li>从磁盘文件中将保存好的外汇数据读取出来</li>
<li>根据索引返回汇率列表中的指定汇率数据</li>
<li>根据索引返回汇率列表中的指定汇率数据</li>
</ul>
<p>代码实现：</p>
<p><strong>方法声明:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRatesList</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">private</span>:<br>	ExchangeRate* _firstRecord = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">// 该指针用来指向第一条数据</span><br>	<span class="hljs-keyword">int</span> _recordCount = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 返回从服务器读取到的货币汇率数量</span><br>	<span class="hljs-keyword">public</span>:<br>	CRatesList();<br>	<span class="hljs-comment">// 构造函数，程序运行从服务器获取数据 </span><br>	~CRatesList();<br>	<span class="hljs-comment">// 在这里释放内存</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReadFromInternet</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-comment">// 从服务器一次性获取最新的数据</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetCount</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-comment">// 返回从服务器获取的外汇牌价数量</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SaveToFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span></span>;<br>	<span class="hljs-comment">// 将从服务器获取的外汇数据保存到指定磁盘文件内</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LoadFromFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span></span>;<br>	<span class="hljs-comment">// 从磁盘文件中将保存好的外汇数据读取出来</span><br>	<span class="hljs-function">ExchangeRate* <span class="hljs-title">GetRatesByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br>	<span class="hljs-comment">// 根据索引返回汇率列表中的指定汇率数据</span><br>	<span class="hljs-function">ExchangeRate* <span class="hljs-title">GetRatesByCode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)</span></span>;<br>	<span class="hljs-comment">// 根据索引返回汇率列表中的指定汇率数据</span><br>	<span class="hljs-function">ExchangeRate* <span class="hljs-title">GetRatesByPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageIndex, <span class="hljs-keyword">int</span> pageSize)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法实现:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CRatesList.h&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">构造函数：在类创建时会自动执行，和类名一样，无返回值</span><br><span class="hljs-comment">*/</span><br>CRatesList::CRatesList() <br>&#123;<br>  <span class="hljs-comment">// 类实例创建就从服务器获取所有数据</span><br>  ReadFromInternet();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">析构函数：在类的实例被销毁的时候会自动执行的函数，只是在类名前添加了一个 &quot;~&quot; 符号</span><br><span class="hljs-comment">*/</span><br>CRatesList::~CRatesList() <br>&#123;<br>  <span class="hljs-keyword">if</span> (_firstRecord != <span class="hljs-literal">NULL</span>) <br>  &#123;<br>    <span class="hljs-built_in">free</span>(_firstRecord);<br>    <span class="hljs-comment">// 程序结束后，释放内存空间</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRatesList::ReadFromInternet</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  ReadAllBOCRates()函数的内部会根据服务器返回的牌价数量，为其分配一块内存空间</span><br><span class="hljs-comment">  这里将 _firstRecord指针变量的地址传入ReadAllBOCRates()函数中</span><br><span class="hljs-comment">  便于ReadBOCRates()函数内部去改变_firstRecord指针变量的值，使其指向存储汇率数据的内存空间</span><br><span class="hljs-comment">  */</span><br>  _recordCount = ReadAllBOCRates(&amp;_firstRecord);<br>  <span class="hljs-comment">// ReadAllBOCRates()函数内部存在分配内存，返回内存地址的情况，</span><br>  <span class="hljs-comment">// 所以程序结束就需要进行释放，释放工作交给析构函数</span><br>  <span class="hljs-keyword">if</span> (_recordCount &lt; <span class="hljs-number">0</span>) <br>  &#123;<br>  _recordCount = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> _recordCount;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRatesList::GetCount</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> _recordCount;<br>  <span class="hljs-comment">// 返回从服务器获取的外汇币种总数和</span><br>&#125;<br><br><span class="hljs-comment">// 将从服务器获取的数据保存到指定的本地磁盘内</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRatesList::SaveToFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span> </span><br><span class="hljs-function"></span>&#123;<br>  assert(_firstRecord != <span class="hljs-literal">NULL</span> &amp;&amp; _recordCount &gt; <span class="hljs-number">0</span>);<br>  FILE* fp = fopen(fileName, <span class="hljs-string">&quot;wb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (fp != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>  <span class="hljs-comment">// 条件成立，将数据读入磁盘文件内</span><br>  fwrite(_firstRecord, <span class="hljs-keyword">sizeof</span>(ExchangeRate) * _recordCount, <span class="hljs-number">1</span>, fp);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从服务器读取的外汇数据，已经保存到本地磁盘文件中\r\n&quot;</span>);<br>  fclose(fp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 从磁盘读取保存好的数据</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRatesList::LoadFromFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fileName)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 此时如果调用者要求从磁盘文件中读取数据</span><br>  <span class="hljs-comment">// 这就说明调用者要放弃原来已有的数据</span><br>  <span class="hljs-keyword">if</span> (_firstRecord != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-comment">// 释放内存，从本地磁盘读取</span><br>    <span class="hljs-built_in">free</span>(_firstRecord);<br>  &#125;<br>  FILE* fp = fopen(fileName, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (fp != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-keyword">int</span> fileLen = filelength(fileno(fp));<br>    <span class="hljs-comment">// 获取文件字节大小</span><br>    _firstRecord = (ExchangeRate*)<span class="hljs-built_in">malloc</span>(fileLen);<br>    <span class="hljs-comment">// 根据文件的字节大小分配内存，并将空间的首地址指向给_firstRecord指针</span><br>    <span class="hljs-keyword">if</span> (_firstRecord != <span class="hljs-literal">NULL</span>) <br>    &#123;<br>      fread(_firstRecord, fileLen, <span class="hljs-number">1</span>, fp);<br>      <span class="hljs-comment">// 内存分配成功，就从磁盘读取文件</span><br>      _recordCount = fileLen / <span class="hljs-keyword">sizeof</span>(ExchangeRate);<br>      <span class="hljs-comment">// 改变_recordCount成员的值</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;磁盘文件读取成功\r\n&quot;</span>);<br>      fclose(fp);<br>      <span class="hljs-comment">// 返回值为 0 ，表示数据读取成功</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      _recordCount = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 返回值为 -1 ，表示内存分配失败</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    _recordCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 返回值为 -2 ，表示文件打开失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 根据索引返回数据</span><br><span class="hljs-function">ExchangeRate* <span class="hljs-title">CRatesList::GetRatesByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>  assert(_firstRecord != <span class="hljs-literal">NULL</span> &amp;&amp; _recordCount &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; _recordCount - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 如果上面的任意条件不成立，下面的语句就不会执行</span><br>  <span class="hljs-keyword">return</span> _firstRecord + index;<br>&#125;<br><span class="hljs-comment">// 根据指定货币代码获取汇率的数据</span><br><span class="hljs-function">ExchangeRate* <span class="hljs-title">CRatesList::GetRatesByCode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// TODO：根据指定货币代码获取汇率的数据</span><br>  <span class="hljs-comment">// 可做一个循环，根据code进行查找</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 分页显示</span><br><span class="hljs-function">ExchangeRate* <span class="hljs-title">CRatesList::GetRatesByPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageIndex, <span class="hljs-keyword">int</span> pageSize)</span></span><br><span class="hljs-function"></span>&#123;<br>  ExchangeRate* Temp = _firstRecord;<br>  ExchangeRate* Temp1 = Temp;<br>  <span class="hljs-keyword">if</span> (Temp != <span class="hljs-literal">NULL</span> &amp;&amp; Temp1 != <span class="hljs-literal">NULL</span>) <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pageIndex; i++) <br>    &#123;<br>      _firstRecord = _firstRecord + <span class="hljs-number">7</span>;<br>    &#125;<br>    Temp1 = _firstRecord;<br>    _firstRecord = Temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Temp1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="汇率数据的显示"><a href="#汇率数据的显示" class="headerlink" title="汇率数据的显示"></a>汇率数据的显示</h4><p>基于 <code>Boxs</code> 父类创建一个 <code>CTextBoxs</code> 子类，该子类用于显示汇率数据</p>
<p><strong>方法的声明</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTextBoxs</span> :</span> <span class="hljs-keyword">public</span> CBoxs<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> _top;<br>  <span class="hljs-keyword">int</span> _left;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDataPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRatesCodeName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRatesCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)</span></span>;<br>  <span class="hljs-comment">// 再指定位置输出数据信息</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRatesData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, ExchangeRate* record)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>方法的定义</strong></p>
<p>需要对外汇数据做判断，数据小于0不显示，代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CTextBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CTextBoxs::SetDataPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left)</span> </span><br><span class="hljs-function"></span>&#123;<br>  _top = top;<br>  _left = left;<br>&#125;<br><span class="hljs-comment">// Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CTextBoxs::ShowRatesCodeName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span> </span><br><span class="hljs-function"></span>&#123;<br>  outtextxy(top, left + <span class="hljs-number">30</span>, str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CTextBoxs::ShowRatesCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)</span> </span><br><span class="hljs-function"></span>&#123;<br>  outtextxy(top, left + <span class="hljs-number">30</span>, code);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CTextBoxs::ShowRatesData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, ExchangeRate* record)</span></span><br><span class="hljs-function"></span>&#123;<br>  LOGFONT f;<br>  gettextstyle(&amp;f);<br>  <span class="hljs-comment">// 获取当前字体设置</span><br>  f.lfHeight = <span class="hljs-number">15</span>;<br>  <span class="hljs-comment">// 设置字体高度为 30</span><br>  _tcscpy(f.lfFaceName, _T(<span class="hljs-string">&quot;楷体&quot;</span>));<br>  <span class="hljs-comment">// 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数)</span><br>  f.lfQuality = ANTIALIASED_QUALITY;<br>  <span class="hljs-comment">// 设置输出效果为抗锯齿  </span><br>  settextstyle(&amp;f);<br>  <span class="hljs-comment">// 设置字体样式</span><br>  <span class="hljs-keyword">char</span> Datas[<span class="hljs-number">30</span>];<br>  <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%s&quot;</span>, record-&gt;CurrencyName);<br>  outtextxy(<span class="hljs-number">190</span>, left + <span class="hljs-number">30</span>, Datas);<br>  <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%s&quot;</span>, record-&gt;CurrencyCode);<br>  outtextxy(<span class="hljs-number">340</span>, left + <span class="hljs-number">30</span>, Datas);<br>  <br>  <span class="hljs-comment">// 外汇数据小于0不显示</span><br>  <span class="hljs-keyword">if</span> (record-&gt;BuyingRate &gt; <span class="hljs-number">0</span>) <br>  &#123;<br>    <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%.2lf&quot;</span>, record-&gt;BuyingRate);<br>    outtextxy(<span class="hljs-number">460</span>, left + <span class="hljs-number">30</span>, Datas);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (record-&gt;CashBuyingRate &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%.2lf&quot;</span>, record-&gt;CashBuyingRate);<br>    outtextxy(<span class="hljs-number">600</span>, left + <span class="hljs-number">30</span>, Datas);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (record-&gt;SellingRate &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%.2lf&quot;</span>, record-&gt;SellingRate);<br>    outtextxy(<span class="hljs-number">740</span>, left + <span class="hljs-number">30</span>, Datas);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (record-&gt;CashSellingRate &gt; <span class="hljs-number">0</span>) <br>  &#123;<br>    <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%.2lf&quot;</span>, record-&gt;CashSellingRate);<br>    outtextxy(<span class="hljs-number">860</span>, left + <span class="hljs-number">30</span>, Datas);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (record-&gt;MiddleRate &gt; <span class="hljs-number">0</span>) <br>  &#123;<br>    <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%.2lf&quot;</span>, record-&gt;MiddleRate);<br>    outtextxy(<span class="hljs-number">980</span>, left + <span class="hljs-number">30</span>, Datas);<br>  &#125;<br>  <span class="hljs-comment">// DateTimes</span><br>  <span class="hljs-built_in">sprintf</span>(Datas, <span class="hljs-string">&quot;%s&quot;</span>, record-&gt;PublishTime);<br>  outtextxy(<span class="hljs-number">1090</span>, left + <span class="hljs-number">30</span>, Datas);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="各类方法的调用"><a href="#各类方法的调用" class="headerlink" title="各类方法的调用"></a>各类方法的调用</h4><p><code>main()</code> 函数就是实现各”功能的组装”</p>
<p>代码实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CExchange.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CRatesList.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CPictureBoxs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CTextBoxs.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  CExchange init;<br>  init.showGraphic();<br>  init.displayBox(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">450</span>, <span class="hljs-number">55</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  init.displayBox(<span class="hljs-number">500</span>, <span class="hljs-number">50</span>, <span class="hljs-number">780</span>, <span class="hljs-number">55</span>, RGB(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>));<br>  init.displayBox(<span class="hljs-number">830</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1280</span>, <span class="hljs-number">55</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>  &#123;<br>    CRatesList ratesList;<br>    <span class="hljs-keyword">int</span> count = ratesList.GetCount();   <span class="hljs-comment">// 获取总记录数</span><br>    <span class="hljs-keyword">int</span> pageCount = <span class="hljs-number">4</span>;                  <span class="hljs-comment">// 汇率页数 </span><br>    <span class="hljs-comment">// 页数循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pageIndex = <span class="hljs-number">0</span>; pageIndex &lt; pageCount; pageIndex++)<br>    &#123;<br>      ExchangeRate* recout = ratesList.GetRatesByPage(pageIndex, <span class="hljs-number">7</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">7</span>; index++)<br>      &#123;<br>        ExchangeRate* records = recout + index;<br>        <span class="hljs-comment">// 显示数据</span><br>        CTextBoxs textBoxs;<br>        textBoxs.ShowRatesData(<span class="hljs-number">90</span> * (<span class="hljs-number">1</span> + index), records);<br>        <span class="hljs-comment">// 根据索引及货币代码从图片文件夹内显示对应的货币图片</span><br>        <span class="hljs-keyword">char</span> flagUrl[<span class="hljs-number">39</span>] = &#123; <span class="hljs-string">&quot;D:\\CR37\\BOCExchangeRate\\flag\\&quot;</span> &#125;;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* suffix = <span class="hljs-string">&quot;.bmp&quot;</span>;<br>        <span class="hljs-keyword">char</span>* completeFlagUrl = <span class="hljs-literal">NULL</span>;<br>        completeFlagUrl = records-&gt;CurrencyCode;<br>        <span class="hljs-comment">// 字符串拷贝</span><br>        <span class="hljs-built_in">strcat</span>(completeFlagUrl, suffix);<br>        <span class="hljs-built_in">strcat</span>(flagUrl, completeFlagUrl);<br>        <span class="hljs-comment">// 显示图片信息</span><br>        CPictureBoxs pictureBoxs;<br>        pictureBoxs.LoadBMPFromFile(flagUrl);<br>        pictureBoxs.SetImagesSize(<span class="hljs-number">80</span>, <span class="hljs-number">80</span>);<br>        pictureBoxs.SetImagesPosition(<span class="hljs-number">90</span> * (<span class="hljs-number">1</span> + index), <span class="hljs-number">50</span>);<br>        pictureBoxs.ShowPicture();<br>      &#125;<br>      Sleep(<span class="hljs-number">2000</span>);<br>      clearrectangle(<span class="hljs-number">10</span>, <span class="hljs-number">90</span>, <span class="hljs-number">1270</span>, <span class="hljs-number">710</span>);<br>    &#125;<br>  &#125;<br>  getch();<br>  closegraph();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="程序运行效果图"><a href="#程序运行效果图" class="headerlink" title="程序运行效果图"></a>程序运行效果图</h3><p><img src="BOC.gif"></p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>通过这次的项目实践，发现自己还有好多知识需要去学习，去实践，去验证。<strong>Tony He</strong> 老师有20多年的开发经验，他告诉我们再学习期间，遇到问题的时候，可以尝试去画图，多去思考，在写项目的时候，每个函数（方法）都只做”一件事情”，就是只完成一个功能，这样才能捋清思路，做着这件事不用去考虑其它事情。自己静下心来，想一想确实如此。</p>
]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的文件操作的使用</title>
    <url>/posts/48585443/</url>
    <content><![CDATA[<p>文件操作的使用以注意事项。</p>
<a id="more"></a>

<h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><p>变量、数组、结构体都是存储数据的方式<br>结构体是一种变量的模板，相对于变量、它可以存储多项数据，相对于数组，结构体中成员的数据类型可以不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">staff</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> FullName[<span class="hljs-number">64</span>];    <span class="hljs-comment">// 一个汉字占用两个字节</span><br>  <span class="hljs-keyword">char</span> Gender;          <span class="hljs-comment">// 字符型变量可以存储整数 1--男 2--女 char类型范围：-127~128</span><br>  <span class="hljs-keyword">char</span> ID[<span class="hljs-number">18</span>];<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">除了使用（struct 结构体名 变量名）这种方式声明结构体变量以外，</span><br><span class="hljs-comment">还可以使用typedef语句来基于结构体声明数据类型</span><br><span class="hljs-comment">这个语句的作用就是将结构体 Staff 定义为新的数据类型 STAFF</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">staff</span> <span class="hljs-title">STAFF</span>;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 定义完结构体后，就可以基于结构体 声明结构体变量</span><br>  STAFF s;<br>  <span class="hljs-comment">// struct staff s;</span><br>  s.Gender = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 为结构体成员变量赋值</span><br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s.FullName);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, s.FullName);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过结构体将多个不同类型的数据结构成员整合在一起，可以方便的多项数据进项操作。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在C语言中之前使用过的变量、数组都是存储在内存（RAM）中的，这些数据所占用的内存在程序结束以后会被操作系统回收，内存中的数也就会随之丢失。因此我们就需要将数据保存到外部存储器上（通常指硬盘），方便其下次使用。<br>在一些较为底层的语言里，你可以直接访问硬盘的某个扇区并进行数读写，但这种返回时除了效率比较低外还存在较大的安全隐患，不恰当的磁盘访问可能会引起严重的故障，比如操作系统崩溃或数丢失。所以这种方式是不推荐的。<br>因此我们就需要通过文件来访问磁盘上的数据，文件系统由操作系统管理，程序员通过这种操作系统可以间接地访问磁盘上地数据，不恰当地访问就可能会被操作系统阻止（例如文件被其它程序占用、或者程序没有访问这个文件的权限），这样一来就会安全得多，同时操作系统也会采取一些机制来提高文件的访问效率。</p>
<h4 id="使用fopen-函数"><a href="#使用fopen-函数" class="headerlink" title="使用fopen()函数"></a>使用fopen()函数</h4><p>fopen()函数可以打开或创建文件，想要将数据存储到磁盘上，首先我们就需要在磁盘上创建一个文件；如果这个文件已经创建，那么我们就需要打开它即可（可以直接打开，也可以进行覆盖，具体操作取决于你打开文件的方式）。在C语言中创建和打开文件都使用一个函数，fopen()函数，该函数的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">FILE* <span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* mode)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数的2个参数都是字符串常量</span><br><span class="hljs-comment">参数1：要打开或创建文件的具体路径</span><br><span class="hljs-comment">参数2：打开或创建文件的具体方式</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h4 id="使用fwrite-函数将读取到对应货币的数据写入到指定路径的文件中："><a href="#使用fwrite-函数将读取到对应货币的数据写入到指定路径的文件中：" class="headerlink" title="使用fwrite()函数将读取到对应货币的数据写入到指定路径的文件中："></a>使用fwrite()函数将读取到对应货币的数据写入到指定路径的文件中：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 定义一个结构体变量</span><br>  ExchangeRate r;<br>  <span class="hljs-comment">// 使用ReadBOCRatesByCode函数读取指定货币对应的值到 &amp;r 所指向的结构体中</span><br>  ReadBOCRatesByCode(<span class="hljs-string">&quot;USD&quot;</span>, &amp;r);<br>  <span class="hljs-comment">// 以二进制形式打开或创建指定路径下的Rates.txt文件</span><br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>  <span class="hljs-comment">// 做判断</span><br>  <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开失败！\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开成功，文件的信息存储在一个结构体中，指针fp指向了这个结构体\r\n&quot;</span>);<br>    <span class="hljs-comment">// 将内存中&amp;r地址中的数据值 读取sizeof(ExchangeRate)大小的字节 保存到fp指向的文件内</span><br>    fwrite(&amp;r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-comment">// 使用后要记得关闭文件</span><br>    fclose(fp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="1.png"></p>
<h4 id="使用fread-函数将指定路径的文件中的数据读出来："><a href="#使用fread-函数将指定路径的文件中的数据读出来：" class="headerlink" title="使用fread()函数将指定路径的文件中的数据读出来："></a>使用fread()函数将指定路径的文件中的数据读出来：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 定义一个结构体变量</span><br>  ExchangeRate r;<br>  <span class="hljs-comment">// 以只读的方式打开对应路径下的文件</span><br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-comment">// 从fp 指向的位置 读取sizeof(ExchangeRate)字节的数据 送到&amp;r所指向的位置</span><br>  fread(&amp;r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>  <span class="hljs-comment">// 打印对应的值</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyCode);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyName);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.PublishTime);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.BuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.SellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashBuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashSellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t\n&quot;</span>, r.MiddleRate);<br>  fclose(fp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行的结果：<br><img src="2.png"></p>
<h4 id="通过自定义函数实现和main-中相同的功能"><a href="#通过自定义函数实现和main-中相同的功能" class="headerlink" title="通过自定义函数实现和main()中相同的功能"></a>通过自定义函数实现和main()中相同的功能</h4><p>避免main()函数中的语句过于繁琐，更具有模块化，以及程序的可修改性，所以我们需要进行自定义函数，实现文件写入和读取操作等功能：<br>1、写入(保存)函数：int SaveRates(ExchangeRate r);<br>2、读取函数：void LoadRatesFromFile(ExchangeRate* r);<br>3、显示数据：void DisplayRates(ExchangeRate r);<br><strong>Visual 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在联网的基础上将从API上读取指定货币的数据保存到磁盘上</span><br><span class="hljs-comment">在保存数据时，只需要将结构体变量的值传递进去就可以了，此时无需使用指针</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SaveRates</span><span class="hljs-params">(ExchangeRate r)</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>   <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开失败！\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开成功！文件的信息存储在一个结构体中，指针指向了这个结构体\r\n&quot;</span>);<br>    fwrite(&amp;r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里传递结构体变量指针是因为要从磁盘中读取已保存的数据</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadRatesFromFile</span><span class="hljs-params">(ExchangeRate* r)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  fread(r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>  fclose(fp);<br>&#125;<br><span class="hljs-comment">// 输出结构体成员对应的数值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispalyRates</span><span class="hljs-params">(ExchangeRate r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyCode);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyName);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.PublishTime);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.BuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.SellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashBuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashSellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t\n&quot;</span>, r.MiddleRate);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 声明一个结构体变量</span><br>  ExchangeRate r;<br>  <span class="hljs-comment">// 调用ReadBOCRatesCode()函数，获取指定货币的数据</span><br>  ReadBOCRatesByCode(<span class="hljs-string">&quot;JPY&quot;</span>, &amp;r);<br>  <span class="hljs-comment">// 将其获取指定货币的数据保存到指定路径的文件内</span><br>  SaveRates(r);<br>  <br>  <span class="hljs-comment">// 调用LoadRatesFromFile()函数将指定路径的文件内的数据读取出来到对应的结构体成员中</span><br>  LoadRatesFromFile(&amp;r);<br>  <span class="hljs-comment">// 调用DispalyRates()函数，打印对应的结构体成员的数值</span><br>  DispalyRates(r);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Visual 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;D:/CR37/Data/libs/BOCRates/BOCRates.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;D:/CR37/Data/libs/BOCRates/BOCRates.lib&quot;</span>)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在联网的基础上将从API上读取指定货币的数据保存到磁盘上</span><br><span class="hljs-comment">在保存数据时，只需要将结构体变量的值传递进去就可以了，此时无需使用指针</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SaveRates</span><span class="hljs-params">(ExchangeRate r)</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>   <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开失败！\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件打开成功！文件的信息存储在一个结构体中，指针指向了这个结构体\r\n&quot;</span>);<br>    fwrite(&amp;r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里传递结构体变量指针是因为要从磁盘中读取已保存的数据</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadRatesFromFile</span><span class="hljs-params">(ExchangeRate* r)</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\Rates.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  fread(r, <span class="hljs-keyword">sizeof</span>(ExchangeRate), <span class="hljs-number">1</span>, fp);<br>  fclose(fp);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 输出结构体成员对应的数值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispalyRates</span><span class="hljs-params">(ExchangeRate r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyCode);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.CurrencyName);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\t&quot;</span>, r.PublishTime);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.BuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.SellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashBuyingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t&quot;</span>, r.CashSellingRate);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\t\r\n&quot;</span>, r.MiddleRate);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 声明一个结构体变量</span><br>  ExchangeRate rates;<br>  <span class="hljs-keyword">if</span> (ReadBOCRatesByCode(<span class="hljs-string">&quot;JPY&quot;</span>, &amp;rates) == <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">// 条件为真，将读取到的对应数值保存到指定路径文件内</span><br>    SaveRates(rates);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// 如果上面的条件失败，就把本地保存的数读取出来</span><br>    LoadRatesFromFile(&amp;rates);<br>  &#125;<br>  DispalyRates(rates);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="3.png"></p>
<h3 id="使用文件操作打印BMP格式的图片"><a href="#使用文件操作打印BMP格式的图片" class="headerlink" title="使用文件操作打印BMP格式的图片"></a>使用文件操作打印BMP格式的图片</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>现在使用的图片主要为位图和矢量图：<br><strong>矢量图形</strong>：是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。矢量图形与使用像素表示图像的位图不同。<br><strong>位图（Bitmap）</strong>：又称栅格图（英语：Raster graphics）或点阵图，是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。</p>
<h4 id="转换-bmp格式"><a href="#转换-bmp格式" class="headerlink" title="转换.bmp格式"></a>转换.bmp格式</h4><p>需要提前将.png、.jpg等格式的图片通过画图工具转换成.bmp，转换的文件类型需要为24位位图，如下图所示：<br><img src="6.png"></p>
<p><strong>位图(.bmp格式)图片的字节数计算方法：</strong><br><img src="4.png"><br><img src="5.png"></p>
<p><strong>使用WinHex工具以十六进制的方式查看.bmp图，可以看出第一、二字节所表示的字符分别为：’B’、’M’</strong><br><img src="7.png"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Visual-1：读取图片信息"><a href="#Visual-1：读取图片信息" class="headerlink" title="Visual 1：读取图片信息"></a>Visual 1：读取图片信息</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\imgs\\computer1.bmp&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">char</span> tag[<span class="hljs-number">2</span>];<span class="hljs-comment">// 定义一个字符数组</span><br>  fread(tag, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, fp);<span class="hljs-comment">// 字符数组的名称可以隐式的转换成数组的首地址，参数1无需添 加 &amp; 运算符</span><br>  <span class="hljs-keyword">if</span> (tag[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;B&#x27;</span> || tag[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;M&#x27;</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片不是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 输出图片文件的字节大小</span><br>  <span class="hljs-comment">// BMPd文件的第3~6字节保存了图片的字节数</span><br>  <span class="hljs-keyword">int</span> filesize = <span class="hljs-number">0</span>;<br>  fread(&amp;filesize, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, fp);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片的字节大小为：%d 字节\r\n&quot;</span>, filesize);<br>  fclose(fp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="8.png"></p>
<p><strong>BMP文件头信息头的结构体定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// header C结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> type;                     <span class="hljs-comment">// 文件格式 占用2Bytes，必须为&quot;BM&quot;</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size;                           <span class="hljs-comment">// 文件大小，占用4字节</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> reserved1, reserved2;     <span class="hljs-comment">// 保留区 默认设置为0</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset;                         <span class="hljs-comment">// 文件头到图像数据信息偏移字节数</span><br>&#125; HEADER;<br> <br><span class="hljs-comment">// infoheader 结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size;               <span class="hljs-comment">// 文件部分size大小</span><br>   <span class="hljs-keyword">int</span> width;                       <span class="hljs-comment">// 图像宽</span><br>   <span class="hljs-keyword">int</span> height;                      <span class="hljs-comment">// 图像高 </span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> planes;       <span class="hljs-comment">// 位面数 总为1</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> bits;         <span class="hljs-comment">// 素位深 </span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> compression;        <span class="hljs-comment">// 缩类型 </span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> imagesize;          <span class="hljs-comment">// 像大小（字节）</span><br>   <span class="hljs-keyword">int</span> xresolution,yresolution;     <span class="hljs-comment">// 率（水平，垂直</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ncolours;           <span class="hljs-comment">// 所用颜色索引数目 </span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> importantcolours;   <span class="hljs-comment">// 像显示有重要影响的颜色索引数</span><br>&#125; INFOHEADER;<br></code></pre></td></tr></table></figure>
<h5 id="Visual-2：定于结构体，获取BMP图片的一些信息"><a href="#Visual-2：定于结构体，获取BMP图片的一些信息" class="headerlink" title="Visual 2：定于结构体，获取BMP图片的一些信息"></a>Visual 2：定于结构体，获取BMP图片的一些信息</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BMP头文件54字节的结构体声明</span><br><span class="hljs-comment">使用typedef()为struct BitMapHeader结构体定义别名：BIT_MAP_HEADER</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapHeader</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">long</span> Size;              <span class="hljs-comment">// 文件大小</span><br>	<span class="hljs-keyword">short</span> Reserved1;        <span class="hljs-comment">// 保留字，不考虑</span><br>	<span class="hljs-keyword">short</span> Reserved2;        <span class="hljs-comment">// 保留字，同上</span><br>	<span class="hljs-keyword">long</span> OffBits;           <span class="hljs-comment">// 实际位图数据的偏移字节数，即前三个部分长度之和</span><br>&#125;BIT_MAP_HEADER;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BMP信息头，也是一个结构体，其定义了BMP图片的具体参数信息</span><br><span class="hljs-comment">使用typedef()为struct BitMapInfo结构体定义别名：BIT_MAP_INFO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapInfo</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">long</span>   Size;            <span class="hljs-comment">// 指定此结构体的长度，为40   </span><br>	<span class="hljs-keyword">long</span>   Width;           <span class="hljs-comment">// 位图宽   </span><br>	<span class="hljs-keyword">long</span>   Height;          <span class="hljs-comment">// 位图高   </span><br>	<span class="hljs-keyword">short</span>  Planes;          <span class="hljs-comment">// 平面数，为1   </span><br>	<span class="hljs-keyword">short</span>  BitCount;        <span class="hljs-comment">// 采用颜色位数，可以是1，2，4，8，16，24，新的可以是32   </span><br>	<span class="hljs-keyword">long</span>   Compression;     <span class="hljs-comment">// 压缩方式，可以是0，1，2，其中0表示不压缩   </span><br>	<span class="hljs-keyword">long</span>   SizeImage;       <span class="hljs-comment">// 实际位图数据占用的字节数   </span><br>	<span class="hljs-keyword">long</span>   XPelsPerMeter;   <span class="hljs-comment">// X方向分辨率   </span><br>	<span class="hljs-keyword">long</span>   YPelsPerMeter;   <span class="hljs-comment">// Y方向分辨率   </span><br>	<span class="hljs-keyword">long</span>   ClrUsed;         <span class="hljs-comment">// 使用的颜色数，如果为0，则表示默认值(2^颜色位数)   </span><br>	<span class="hljs-keyword">long</span>   ClrImportant;    <span class="hljs-comment">// 重要颜色数，如果为0，则表示所有颜色都是重要的</span><br>&#125;BIT_MAP_INFO;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\imgs\\computer1.bmp&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">char</span> tag[<span class="hljs-number">2</span>];          <span class="hljs-comment">// 定义一个字符数组</span><br>  fread(tag, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, fp); <span class="hljs-comment">// 字符数组的名称可以隐式的转换成数组的首地址，参数1无需添 加 &amp; 运算符</span><br>  <span class="hljs-keyword">if</span> (tag[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;B&#x27;</span> || tag[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;M&#x27;</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片不是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>    <span class="hljs-comment">// 为BMP头文件结构体声明变量</span><br>    BIT_MAP_HEADER bmpHeader;<br>    fread(&amp;bmpHeader, <span class="hljs-keyword">sizeof</span>(bmpHeader), <span class="hljs-number">1</span>, fp);<br>    <br>    <span class="hljs-comment">// 为BMP信息头结构体声明变量</span><br>    BIT_MAP_INFO bmpInfo;<br>    fread(&amp;bmpInfo, <span class="hljs-keyword">sizeof</span>(bmpInfo), <span class="hljs-number">1</span>, fp);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张BMP图片的宽度为：%d\r\n&quot;</span>, bmpInfo.Width);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张BMP图片的高度为：%d\r\n&quot;</span>, bmpInfo.height);<br>  &#125;<br>  fclose(fp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="9.png"><br><img src="10.png"></p>
<p><strong>根据上面使用结构体获取的BMP图片信息，使用initgraph()函数就可以初始化一个对应大小像素的窗口</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">initgraph(bmpInfo.Width, bmpInfo.Height);<br>_getch();<br></code></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="11.png"></p>
<p><strong>给初始化的绘图窗口填充颜色：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">initgraph(bmpInfo.Width, bmpInfo.Height);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt;= bmpInfo.Width; x++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt;= bmpInfo.Height; y++)<br>  &#123;<br>    putpixel(x, y, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="12.png"></p>
<p><strong>从fp读取对应像素点的RGB数值：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">initgraph(bmpInfo.Width, bmpInfo.Height);<br><span class="hljs-comment">// 位图每个像素点的RGB值占用3个字节</span><br><span class="hljs-keyword">char</span> data[<span class="hljs-number">3</span>];   <span class="hljs-comment">// 存储像素点的RGB值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt;= bmpInfo.Width; x++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt;= bmpInfo.Height; y++)<br>  &#123;<br>    <span class="hljs-comment">// 从fp读取数据到data里</span><br>    fread(data, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-comment">// 字符型数据可以转换成整型</span><br>    <span class="hljs-keyword">int</span> r = data[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> g = data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> b = data[<span class="hljs-number">2</span>];<br>    putpixel(i, j, RGB(r, g, b));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果（可以看出结果并不是我们想要的，多以找bug）：<br><img src="13.png"></p>
<p><strong>由于位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。所以需要更改循环条件：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">initgraph(bmpInfo.Width, bmpInfo.Height);<br><span class="hljs-comment">// 位图每个像素点的RGB值占用3个字节</span><br><span class="hljs-keyword">char</span> data[<span class="hljs-number">3</span>];<span class="hljs-comment">// 存储像素点的RGB值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = bmpInfo.Height - <span class="hljs-number">1</span>; y &gt;= <span class="hljs-number">0</span>; y--)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x =<span class="hljs-number">0</span> ; x &lt;= bmpInfo.Width <span class="hljs-number">-1</span>; x++)<br>  &#123;<br>    <span class="hljs-comment">// 从fp读取数据到data里</span><br>    fread(data, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-comment">// 字符型数据可以转换成整型</span><br>    <span class="hljs-keyword">int</span> r = data[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> g = data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> b = data[<span class="hljs-number">2</span>];<br>    putpixel(i, j, RGB(r, g, b));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="14.png"></p>
<p>还可以修改for()循环里的条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = bmpInfo.Height - <span class="hljs-number">1</span>; y &gt;= <span class="hljs-number">0</span>; y--)<br>&#123;<br>  <span class="hljs-comment">// 修改这里的循环条件</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x =bmpInfo.Width <span class="hljs-number">-1</span> ; x &gt;= <span class="hljs-number">0</span>; x--)<br>  &#123;<br>    <span class="hljs-comment">// 从fp读取数据到data里</span><br>    fread(data, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-comment">// 字符型数据可以转换成整型</span><br>    <span class="hljs-keyword">int</span> r = data[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> g = data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> b = data[<span class="hljs-number">2</span>];<br>    putpixel(i, j, RGB(r, g, b));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="15.png"></p>
<h5 id="Visual-3：完整代码"><a href="#Visual-3：完整代码" class="headerlink" title="Visual 3：完整代码"></a>Visual 3：完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BMP头文件54字节的结构体声明</span><br><span class="hljs-comment">使用typedef()为struct BitMapHeader结构体定义别名：BIT_MAP_HEADER</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapHeader</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">long</span> Size;          <span class="hljs-comment">// 文件大小</span><br>	<span class="hljs-keyword">short</span> Reserved1;    <span class="hljs-comment">// 保留字，不考虑</span><br>	<span class="hljs-keyword">short</span> Reserved2;    <span class="hljs-comment">// 保留字，同上</span><br>	<span class="hljs-keyword">long</span> OffBits;       <span class="hljs-comment">// 实际位图数据的偏移字节数，即前三个部分长度之和</span><br>&#125;BIT_MAP_HEADER;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BMP信息头，也是一个结构体，其定义了BMP图片的具体参数信息</span><br><span class="hljs-comment">使用typedef()为struct BitMapInfo结构体定义别名：BIT_MAP_INFO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitMapInfo</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">long</span>   Size;        <span class="hljs-comment">// 指定此结构体的长度，为40   </span><br>	<span class="hljs-keyword">long</span>   Width;       <span class="hljs-comment">// 位图宽   </span><br>	<span class="hljs-keyword">long</span>   Height;      <span class="hljs-comment">// 位图高   </span><br>	<span class="hljs-keyword">short</span>  Planes;      <span class="hljs-comment">// 平面数，为1   </span><br>	<span class="hljs-keyword">short</span>  BitCount;    <span class="hljs-comment">// 采用颜色位数，可以是1，2，4，8，16，24，新的可以是32   </span><br>	<span class="hljs-keyword">long</span>   Compression; <span class="hljs-comment">// 压缩方式，可以是0，1，2，其中0表示不压缩   </span><br>	<span class="hljs-keyword">long</span>   SizeImage;   <span class="hljs-comment">// 实际位图数据占用的字节数   </span><br>	<span class="hljs-keyword">long</span>   XPelsPerMeter;   <span class="hljs-comment">// X方向分辨率   </span><br>	<span class="hljs-keyword">long</span>   YPelsPerMeter;   <span class="hljs-comment">// Y方向分辨率   </span><br>	<span class="hljs-keyword">long</span>   ClrUsed;         <span class="hljs-comment">// 使用的颜色数，如果为0，则表示默认值(2^颜色位数)   </span><br>	<span class="hljs-keyword">long</span>   ClrImportant;    <span class="hljs-comment">// 重要颜色数，如果为0，则表示所有颜色都是重要的</span><br>&#125;BIT_MAP_INFO;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* fp = fopen(<span class="hljs-string">&quot;D:\\CR37\\Data\\imgs\\computer1.bmp&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">char</span> tag[<span class="hljs-number">2</span>];<span class="hljs-comment">// 定义一个字符数组</span><br>  fread(tag, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, fp);<span class="hljs-comment">// 字符数组的名称可以隐式的转换成数组的首地址，参数1无需添 加 &amp; 运算符</span><br>  <span class="hljs-keyword">if</span> (tag[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;B&#x27;</span> || tag[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;M&#x27;</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片不是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这张图片是一张\&quot;.bmp\&quot;图片！\r\n&quot;</span>);<br>    <span class="hljs-comment">// 为BMP头文件结构体声明变量</span><br>    BIT_MAP_HEADER bmpHeader;<br>    fread(&amp;bmpHeader, <span class="hljs-keyword">sizeof</span>(bmpHeader), <span class="hljs-number">1</span>, fp);<br>    <br>    <span class="hljs-comment">// 为BMP信息头结构体声明变量</span><br>    BIT_MAP_INFO bmpInfo;<br>    fread(&amp;bmpInfo, <span class="hljs-keyword">sizeof</span>(bmpInfo), <span class="hljs-number">1</span>, fp);<br>    <br>    initgraph(bmpInfo.Width, bmpInfo.Height);<br>    <span class="hljs-comment">// 位图每个像素点的RGB值占用3个字节</span><br>    <span class="hljs-keyword">char</span> data[<span class="hljs-number">3</span>];   <span class="hljs-comment">// 存储像素点的RGB值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = bmpInfo.Height - <span class="hljs-number">1</span>; y &gt;= <span class="hljs-number">0</span>; y--)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x =<span class="hljs-number">0</span> ; x &lt;= bmpInfo.Width <span class="hljs-number">-1</span>; x++)<br>      &#123;<br>        <span class="hljs-comment">// 从fp读取数据到data里</span><br>        fread(data, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, fp);<br>        <span class="hljs-comment">// 字符型数据可以转换成整型</span><br>        <span class="hljs-keyword">int</span> r = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> g = data[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> b = data[<span class="hljs-number">2</span>];<br>        putpixel(i, j, RGB(r, g, b));<br>        _getch();<br>        closegraph();<br>      &#125;<br>    &#125;<br>  &#125;<br>  fclose(fp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C语言文件操作</tag>
        <tag>BMP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo和Github搭建个人博客</title>
    <url>/posts/2e566f5/</url>
    <content><![CDATA[<p>使用Hexo + Node.js 搭建个人博客。<a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开始讲解博客搭建的过程前，我想还是先来讲讲我为什么要搭建我的个人博客吧。其实在搭建我的个人博客之前呢，我就一直希望能够拥有一个属于自己的个人博客。</p>
<p>为什么呢？<strong>一方面</strong>是因为我觉得学计算机的能够拥有一个属于自己的个人博客是一件非常酷的事情，我们可以用blog来记录我们的学习心得，学习路途中所遇到的问题以及解决方法，以至于在我们下一次又遇到同样问题的时候可以回看下我们之前是怎样处理这些问题的，同时呢，我觉得还可以帮助哪些和我遇到相同问题的同学们，希望我写的文章可以去帮助Ta们。这一点呢我就深有体会，在学计算机的这几年里呢，说实话我也经常会遇到一些让我束手无策的问题。当遇到自己无法解决问题的时候呢，就会去问度娘或者Google一下，当我们使用搜索引擎后，我想搜索引擎就会把之前有人踩过的坑和解决该问题的方法显现在我们面前，这个时候我们就可以去解决我们遇到的问题了。在读大学期间，我也见过国内几大博客平台上好多大佬们坚持写作，把自己遇到的坑，心得体会都分享给我们，让我们后人参考，学习。</p>
<p><strong>另一方面呢</strong>，我想用我的blog来记录下我生活上的一些琐事。我觉得除我们工作、学习外，我们的个人生活它也值得我们去记录，因为未来可期，明日可待吗！能够有一个自己的个人博客，坚持写点东西，我觉得会对我个人的表达能力、思维判断等等会带来很大的好处，以及当遇到问题时不是想着退缩而是想着迎面而上。同时，我也希望我博客里面写的文章多多少少能够帮助一些有同样问题的同学们。<br><strong>那接下来我们再来说说为什么不在现有的博客平台上写作，如何选择一个适合自己的博客方案以及搭建个人博客需要注意的事项。</strong></p>
<ul>
<li>为什么不在现有的博客平台上写作？<br> 确实，现在市面上可以写作的平台也有好几家，例如：csdn、博客园、简书、知乎等。想要在这些平台发表自己的文章只需要在相应平台注册自己的账号就可以开始你的写作之旅。但是有利也有弊，缺点就是各种广告以及平台的各种限制，会让人感觉不自由。我这个人比较爱折腾，自己搭建博客的话可玩性也就相对比较大，这也是要搭建个人博客的主要原因。</li>
<li>如何选择一个适合自己的博客方案。<br> 搭建个人博客需要考虑的事情也挺多的，比如：自己博客的目的性、使用哪家的博客框架、后期主题模板的选择、域名的购买、服务器的购买、博客的安全性等等。单是域名的购买和服务器的购买，以及后期还要定期去维护它，我想对于我们大多数人来讲都会没这个时间和精力。好在我们还有第三种选择，就是将我们的blog托管到GitHub pages平台上。这样前面的问题一些我们就不用考虑了，只需要安心的写作就可以了。</li>
<li>搭建个人博客需要注意的事项。<br> 这个问题其实第二个问题也有涉及到，我就在说说blog框架主流框架都有哪些吧，找一个适合自己的就行，主流的blog框架有：<ul>
<li><a href="https://zh-cn.wordpress.com/">WordPress</a> 是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。</li>
<li><a href="https://halo.run/">halo</a> 基于springboot vue</li>
<li><a href="https://hexo.io/">hexo</a> 基于node.js</li>
<li><a href="https://solo.b3log.org/">solo</a> 基于java,有后台管理</li>
<li><a href="https://vuepress.vuejs.org/zh/">vuepress</a> 基于vue.js</li>
<li><a href="https://www.zblogcn.com/">Z-Blog</a> 基于Asp和PHP，既是博客程序,也是CMS建站系统</li>
<li><a href="https://www.gohugo.org/">hugo</a> 基于go语言，Hugo是由Go语言实现的静态网站生成器</li>
<li><a href="https://emlog.cn/">emlog</a> 基于PHP语言和MySQL</li>
<li><a href="http://typecho.org/">typecho</a> 基于PHP5开发，轻量级开源博客程序</li>
<li><a href="http://jekyllcn.com/">jekyll</a> 一个简单的免费的Blog生成工具，类似WordPress，它可以将纯文本转换为静态博客网站</li>
</ul>
</li>
</ul>
<p>我用的是hexo，Hexo是基于Node.js，是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo支持的插件多达320种，主题样式多达290多种也有很多好看的，目前hexo在GitHub上star数量高达29.6k，fork数量高达3.8k，足以说明hexo挺受欢迎的。使用Hexo博客框架，可以快速搭建属于自己的个人静态博客，在把blog托管到GitHub Pages上去，就可以省去服务器维护的时间和精力。</p>
<h3 id="博客搭建前的准备工作"><a href="#博客搭建前的准备工作" class="headerlink" title="博客搭建前的准备工作"></a>博客搭建前的准备工作</h3><ul>
<li>在开始搭建自己的个人博客之前你必须要有一个<a href="https://github.com/">GitHub</a>账号，如果没有的话点击前面的GitHub去注册一个吧。</li>
<li>下载<a href="https://nodejs.org/zh-cn/">node.js</a>安装包，因为hexo是基于node.js，所以我们需要下载并安装node.js，这里推荐大家下载长期支持版(LTS)。</li>
<li>安装<a href="https://git-scm.com/downloads">Git</a>工具，根据自己的电脑环境下载相应的版本，我用的Windows10，所以只需要点击Windows图标下载即可。</li>
</ul>
<h3 id="使用Hexo和Github博客搭建的步骤"><a href="#使用Hexo和Github博客搭建的步骤" class="headerlink" title="使用Hexo和Github博客搭建的步骤"></a>使用Hexo和Github博客搭建的步骤</h3><ul>
<li>安装Git版本控制工具</li>
<li>打开Git bash配置全局用户名及邮箱</li>
<li>安装node.js</li>
<li>打开Git bash使用npm安装cnpm</li>
<li>打开Git bash使用cnpm安装hexo</li>
<li>使用hexo初始化我们的blog</li>
<li>进行本地启动</li>
<li>在GitHub上创建存放我们blog的存储库</li>
<li>修改相关配置</li>
<li>将本地blog部署到我们的GitHub存储库</li>
<li>配置SSH key</li>
</ul>
<h3 id="安装Git版本控制工具"><a href="#安装Git版本控制工具" class="headerlink" title="安装Git版本控制工具"></a>安装Git版本控制工具</h3><ul>
<li>找到下载好的Git工具安装包，然后鼠标右击以管理员身份运行，进行安装操作。<br><img src="20200222174957.jpg"></li>
<li>由于我之前已经安装过了，所以我就不在安装了，只需要打开安装程序，一直点击”Next”即可。</li>
<li>安装完成后，我们就可以用鼠标右击桌面一下，点击<code>Git Bash Here</code>，打开git bash命令窗口查看git是否安装成功以及版本信息。<br><img src="20200222182829.jpg"></li>
</ul>
<h3 id="打开Git-bash配置全局用户名及邮箱"><a href="#打开Git-bash配置全局用户名及邮箱" class="headerlink" title="打开Git bash配置全局用户名及邮箱"></a>打开Git bash配置全局用户名及邮箱</h3><ul>
<li>切到系统桌面，然后我们用鼠标右击桌面一下，点击<code>Git Bash Here</code>，打开git bash命令窗口即可。<br><img src="20200222175947.jpg"></li>
<li>分别输入下面的两个命令，进行全局用户名及邮箱的配置。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">git config --global user.name <span class="hljs-string">&quot;name&quot;</span>    <span class="hljs-comment">// 引号里面的name，需要改写成你的GitHub用户名</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span>  <span class="hljs-comment">// 引号里面的email，需要改写成你注册GitHub时填写的电子邮箱</span><br></code></pre></td></tr></table></figure></li>
<li>配置全局用户名及邮箱需要和GitHub上的信息一致，例如：<br><img src="20200222181743.jpg"></li>
</ul>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><ul>
<li>和安装Git版本控制工具一样，鼠标右键安装下载好的node.js安装包即可，安装过程中同样也是一直点击”Next”即可。<br><img src="20200222174920.jpg"></li>
<li>安装完成后，同样的方式打开Git Bash，输入<code>node -v</code>查看版本信息来确认node.js是否安装成功。node.js成功后会有两个组件，一个是node.js本身，另一个是npm包管理器，这两个组件是搭建hexo博客时必须要用到的。同时输入<code>npm -v</code>查看npm包管理器的版本信息，如下图所示：<br><img src="node_npm.jpg"></li>
</ul>
<h3 id="打开Git-bash使用npm安装cnpm"><a href="#打开Git-bash使用npm安装cnpm" class="headerlink" title="打开Git bash使用npm安装cnpm"></a>打开Git bash使用npm安装cnpm</h3><ul>
<li>说明：由于国内的镜像源速度比较慢，使用<code>npm</code>安装必要插件需要从国外服务器进行下载，受网络影响，可能会出现异常，因此我们这里需要借助<code>npm</code>来安装<code>cnpm</code>。<code>cnpm</code>就是所说的淘宝镜像，是由我们乐于分享的淘宝团队开发出来的开源产品，这里我们使用<code>cnpm</code>就是为了加速下载相关源文件。如果有想了解<a href="https://npm.taobao.org/">cnpm</a>的同学，我把官网链接给放上了。</li>
<li>安装完node.js后我们就可以正式的安装hexo博客框架，安装hexo时我们会用到npm这个包管理器。上面也给大家说了，在我们大陆我们需要使用淘宝的镜像源<code>cnpm</code>，所以在这里我们需要借助<code>npm</code>来安装<code>cnpm</code>。同样的方式打开Git Bash输入下面这段代码等待安装完成：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">npm install -g cnpm --registry=https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure></li>
<li><code>cnpm</code>安装完成后，我们可以输入<code>cnpm -v</code>来查看cnpm的版本信息，之后我们就可以使用<code>cnpm</code>来安装heox博客框架，由于我之前已经安装过<code>cnpm</code>，在这里就不在安装了。<br><img src="cnpm.jpg"></li>
</ul>
<h3 id="使用cnpm安装Hexo"><a href="#使用cnpm安装Hexo" class="headerlink" title="使用cnpm安装Hexo"></a>使用cnpm安装Hexo</h3><ul>
<li><code>cnpm</code>安装完成后，我们就可以继续在Git Bash里输入下面的代码来正式的安装Hexo博客框架：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cnpm install -g hexo-cli      <span class="hljs-comment">// -g表示全局安装</span><br></code></pre></td></tr></table></figure></li>
<li>使用<code>cnpm</code>安装hexo博客框架很快，网速ok的话也就几秒钟的时间。安装完成后我们可以输入<code>hexo -v</code>来查看hexo的一些版本信息。<br><img src="hexo-v.jpg"></li>
</ul>
<h3 id="使用hexo初始化我们的blog"><a href="#使用hexo初始化我们的blog" class="headerlink" title="使用hexo初始化我们的blog"></a>使用hexo初始化我们的blog</h3><ul>
<li>在使用<code>hexo</code>初始化博客之前我们需要在我们的磁盘上新建一个文件夹，用来存放我们初始化博客时所生成的文件。<br><img src="initialize-blog.jpg"></li>
<li>文件夹创建完成后，我们需要进入到该文件夹，在该文件内打开<code>Git Bash</code>命令行工具。<br><img src="folder.jpg"></li>
<li>在打开的<code>Git Bash</code>命令行里我们就可以使用<code>Hexo</code>来初始化(生成)我们的博客。需要输入以下命令(我的电脑环境是Windows)：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo init<br></code></pre></td></tr></table></figure>
<img src="cloneing-blog.jpg"></li>
<li>出现如下图的提示，就说明我们的博客已经初始化完成了。<br><img src="hexostart.jpg"></li>
<li>我们先来看下文件夹内都生成了哪些文件，文件夹内的<code>_config.yml</code>文件是我们博客的配置文件，也是我们要进行重点修改的文件，在该文件内我们要修改blog的名称、语言、时区、等等。<br><img src="folder-content.jpg"></li>
</ul>
<h3 id="本地启动我们的博客"><a href="#本地启动我们的博客" class="headerlink" title="本地启动我们的博客"></a>本地启动我们的博客</h3><ul>
<li>初始化完成后，我们就可以进行本地启动，输入下面的命令来启动我们的博客：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo server<br></code></pre></td></tr></table></figure></li>
<li>等出现如下图所示时，我们就可以打开浏览器输入<code>http://localhost:4000</code>来进行查看。<br><img src="localhost-hexo.jpg"></li>
<li>输入<code>http://localhost:4000</code>就会出现如下图所示的页面。<br><img src="QQ%E6%88%AA%E5%9B%BE20200223153621.jpg"></li>
<li>在我们进行初始化博客的时候<code>hexo</code>就已经帮我们初始化了一篇名为<code>Hello World</code>的文章，文章里告诉我们一些常用的命令：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span>    <span class="hljs-comment">// 在博客路径下，使用该命令会生成一篇名为 My New Post 的文章</span><br>hexo clear                <span class="hljs-comment">// 清除缓存文件</span><br>hexo generate             <span class="hljs-comment">// 重新生成静态文件</span><br>hexo server               <span class="hljs-comment">// 启动服务器-进行本地浏览测试</span><br>hexo deploy               <span class="hljs-comment">// 部署网站</span><br></code></pre></td></tr></table></figure>
<a href="https://hexo.io/zh-cn/docs/commands.html">hexo指令</a>，前面那句话是hexo相关指令使用方法的官方文档链接，感兴趣的同学可以多了解了解，这些命令我们会经常使用。</li>
<li>我们来使用<code>hexo new &quot;···&quot;</code>命令来新建一篇博客文章，同时给文章添加一些内容并生成进行本地浏览。<br><img src="20200223163703.jpg"></li>
<li>这里我是用<code>vim</code>(是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器)来更改所创建文件的内容，大家也可以<code>nodepad++</code>或者是支持markdown语法的文本编辑器对我们刚才所创建的文件进行添加内容操作，例如：<br><img src="vim.jpg"></li>
<li>更改保存完成后，我们就可以依次输入下面的三个命令，重新进行本地生成、启动并浏览(建议大家每次都依次输入这三个命令)：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo clear    <span class="hljs-comment">// 清除缓存文件</span><br>hexo generate <span class="hljs-comment">// 重新生成静态文件</span><br>hexo server   <span class="hljs-comment">// 启动服务器-进行本地浏览测试</span><br></code></pre></td></tr></table></figure>
<img src="20200223171332.jpg"></li>
</ul>
<p>断开<code>hexo server</code>只需要在Git Bash命令行窗口内按下<code>Ctrl+C</code>就可以。</p>
<h3 id="在GitHub上创建存放我们blog的存储库"><a href="#在GitHub上创建存放我们blog的存储库" class="headerlink" title="在GitHub上创建存放我们blog的存储库"></a>在GitHub上创建存放我们blog的存储库</h3><p>我们前面生成的博客地址是用于本地测试使用的，就是这个<code>http://localhost:4000</code>地址，别的同学无法通过这个地址访问我们的博客，只能我们自己在我们自己的电脑上浏览。我想我们都希望我们的个人博客能够被所有的联网设备(手机、平板、电脑)所访问，因此我们就需要借助Github，将我们的博客上传到我们的GitHub仓库，之后我们就可以通过访问GitHub那个地址来访问我们的blog。所以我们就需要先在GitHub上创建一个仓库。</p>
<ul>
<li>访问<a href="https://github.com/">Github</a>网站，登录我们的个人账号后，点击我们头像左侧的加号按钮，然后单击<code>New repository</code>新建一个存储库。<br><img src="new-repository.jpg"></li>
<li>在创建我们个人博客存储库时，仓库的名称必须符合特定的要求才行，仓库名称必须是<code>我们的GitHub账户名.github.io</code>，例如：<code>ileemi.github.io</code>，<code>ileemi</code>就是我的GitHub用户名，等我们的博客文件上传该存储库后，我们就可以直接在浏览器里输入这个地址来访问我们的博客。<br><img src="create-repository.jpg"></li>
<li>如下图所示，就说明我们的存储库创建成功了，这个<code>https</code>链接我们待会需要使用。<br><img src="20200223222951.jpg"></li>
</ul>
<h3 id="修改相关配置"><a href="#修改相关配置" class="headerlink" title="修改相关配置"></a>修改相关配置</h3><p>在将我们的个人博客部署到GitHub仓库之前，我们需要打开博客文件夹下的<code>_config.yml</code>文件，进行一个特别重要的配置。</p>
<ul>
<li>在blog文件夹内打开<code>_config.yml</code>文件或者使用git工具自带的vim进行相应的配置。打开该文件，找到<code>#Deployment</code>下面的<code>deploy</code>项，如下图所示：<br><img src="20200223231623.jpg"></li>
<li>然后将<code>deploy</code>下的内容更改成如下图所示(更改后记得保存)：<br><img src="20200223231244.jpg"></li>
</ul>
<h3 id="将本地blog部署到我们的GitHub存储库"><a href="#将本地blog部署到我们的GitHub存储库" class="headerlink" title="将本地blog部署到我们的GitHub存储库"></a>将本地blog部署到我们的GitHub存储库</h3><p>在将我们的本地博客部署到我们的GitHub存储库之前，我们需要在我们本地的博客目录下安装一个部署插件，在我们博客目录下打开<code>Git Bash</code>输入以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure>
<p>出现下图提示，就说明部署插件安装成功。<br><img src="20200224000028.jpg"></p>
<p>将我们的本地blog文件部署到我们远端的GitHub存储库需要依次输入下面的命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo clear    <span class="hljs-comment">// 清除缓存文件</span><br>heox generate <span class="hljs-comment">// 重新生成静态文件</span><br>heox deploy   <span class="hljs-comment">// 部署网站</span><br></code></pre></td></tr></table></figure>

<p>在使用<code>hexo deploy</code>进行部署的时候，如果进行的比较大的修改，运行该命令期间会要求我们输入GitHub的账号及密码，这个时候我们只需要依次输入账号密码即可，如下面的两张图所示：<br><img src="QQ%E6%88%AA%E5%9B%BE20200224140544.jpg"> <img src="QQ%E6%88%AA%E5%9B%BE20200224140605.jpg"></p>
<p>接下来我就在我的blog目录下运行这三个命令，部署完成后会出现如下图所示的提示：<br><img src="20200224001848.jpg"></p>
<p>部署完成后我们就可以去我们的GitHub存储库查看上传信息：<br><img src="deploy.jpg"></p>
<p>然后，我们就可以直接通过我们创建GitHub存储库时所起的存储库名来直接访问我们的博客，这样一来所有的联网设备(手机、平板、电脑)都可以通过这个地址来访问我们的博客。例如：直接在浏览器中输入<code>ileemi.github.io</code>，就可以访问到我们的博客，如下图所示：<br><img src="20200224003430.jpg"></p>
<h3 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h3><p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH 通过在网络中创建安全隧道来实现 SSH 客户端与服务器之间的连接。SSH 以非对称加密实现身份验证。身份验证有多种途径，例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的计算机之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。<a href="https://ispeak.vibaike.com/29176">来源于全球百科</a><br>简单来说，SSH 是一种网络协议，利用 SSH 协议可以有效防止远程登录过程中的信息泄露问题，常用于计算机之间的加密登录。所在在我们配置完 SSH key 后我们再使用<code>heox deploy</code>命令进行部署时就可以免输用户名和密码。<br>配置 SSH key 的具体步骤：</p>
<ul>
<li><p>首先我们需要打开<code>Git Bash</code>命令行工具(鼠标任意位置右键点击即可)，输入<code>ls -al ~/.ssh</code>命令来检查之前是否有配置过 SSH key。运行命令后如果显示如下图红框里的提示，说明当前我们还没有配置过 SSH key，如果之前有配置过，可以直接删除.ssh文件夹里面所有文件，重新生成下。<br><img src="ssh.jpg"></p>
</li>
<li><p>使用<code>ssh-keygen</code>生成密钥，在打开的<code>Git Bash</code>命令行内输入下面的命令生成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@example.com&quot;</span> <span class="hljs-comment">// 邮箱必须是我们注册Github时的邮箱</span><br># 例如<br>$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;ileemi@163.com&quot;</span>       <span class="hljs-comment">// 我的邮箱	</span><br>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key <span class="hljs-built_in">pair</span>.<br><span class="hljs-function">Enter file in which to save the <span class="hljs-title">key</span> <span class="hljs-params">(/c/Users/lh/.ssh/id_rsa)</span>:  <span class="hljs-comment">// 这里要我们输入保存密钥的文件夹名称，不想输入直接enter默认就行</span></span><br></code></pre></td></tr></table></figure>
<p>接下来会问我们是否输入<code>passphrase</code>密码短语，如果想设置，那这里设置的密码要牢记，这里我就不设置了，直接enter。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">Created directory &#x27;/c/Users/lh/.ssh&#x27;.<br><span class="hljs-function">Enter <span class="hljs-title">passphrase</span> <span class="hljs-params">(empty <span class="hljs-keyword">for</span> no passphrase)</span>:   <span class="hljs-comment">// 不想设置密码短语的话直接enter</span></span><br><span class="hljs-function">Enter same passphrase again:                  <span class="hljs-comment">// 同上可直接enter</span></span><br></code></pre></td></tr></table></figure>
<p>密钥生成后，就会出现下面的提示：<br><img src="key.jpg"> <img src="id_rsa.jpg"></p>
</li>
<li><p>这里我们需要打开C盘的用户目录下找到 <code>.ssh\id_rsa.pub</code>文件，用记事本或者nodepad++打开并复制里面的内容，接着打开我们的Github主页，点击个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，将复制的公钥粘贴到<code>Key</code>里面，Title这里随便填写，完成后点击<code>Add SSH key</code>按钮，之后会让我们输入我们的GitHub密码进行验证。输入后如下图所示即可：<br><img src="newsshkey.jpg"> <img src="sshkeypub.jpg"></p>
</li>
<li><p>接着需要测试是否成功，在<code>Git Bash</code>命令行里输入下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">ssh -T git@github.com		<span class="hljs-comment">// 这里不需要改动，输入后直接enter就行	</span><br></code></pre></td></tr></table></figure>
<p>如果出现Are you sure you want to continue connecting (yes/no)?提示，直接输入yes就行，然后就会看到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs C++">Hi ileemi! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.		//出现这个提示就说明SSH key配置成功乐<br></code></pre></td></tr></table></figure></li>
<li><p><code>SSH key</code>配置完成后，还有一个重要的步骤就是需要我们去博客的根目录下打开<code>_config.yml</code>文件，对deploy部分进行如下配置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找到这个地方</span><br>deploy:<br>type: git<br>repository: https:<span class="hljs-comment">//github.com/ileemi/ileemi.github.io.git</span><br>branch: master<br><br><span class="hljs-comment">// 将repository项更改为</span><br>repository: git@github.com:ileemi/ileemi.github.io.git <br></code></pre></td></tr></table></figure></li>
<li><p>完后上面额步骤后，就可以依次使用下面的命令对我们的博客进行部署：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">hexo clear      <span class="hljs-comment">// 清除缓存文件</span><br>heox generate   <span class="hljs-comment">// 重新生成静态文件</span><br>heox deploy     <span class="hljs-comment">// 部署网站</span><br><br><span class="hljs-comment">// 每次进行本地测试(hexo server)或者部署(hexo deploy)前，</span><br><span class="hljs-comment">// 建议都先使用hexo clear、hexo generate这两个命令</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>到这里我们的个人博客部署就已经完成了，后期我们还需要花时间对我们的博客的进行美化，更换主题，添加小功能等等。先把<a href="https://hexo.io/zh-cn/docs/index.html">Hexo的官方文档</a>给放在这里，感兴趣的同学可以先了解下。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/av44544186?from=search&seid=13039463800362316212">codesheep</a><br><a href="https://blog.csdn.net/hhgggggg/article/details/77853665">冰镇-西瓜</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>搭建个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义函数和字符串处理以及EasyX图形库</title>
    <url>/posts/3fe6e553/</url>
    <content><![CDATA[<p>自定义函数和字符串处理以及EasyX图形库的简单使用。 <a id="more"></a></p>
<h3 id="字符串常量的存储"><a href="#字符串常量的存储" class="headerlink" title="字符串常量的存储"></a>字符串常量的存储</h3><p>1、由一对双引号包含的若干字符<br>2、使用malloc()函数分配一块空间用于存储多个字符</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 通过内存分配，直接使用分配到的内存来存储数据</span><br><span class="hljs-keyword">char</span>* ptr_c = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure>

<h3 id="进程对内存的使用"><a href="#进程对内存的使用" class="headerlink" title="进程对内存的使用"></a>进程对内存的使用</h3><p>说明：本段参考Tony He老师的《换个姿势学C语言 》<br>一个应用程序被启动后至少会启动一个进程，同一个应用程序被启动多次则会启动多个进程。在32位版本的Windows下运行的所有进程都分配最多4GB的内存空间，这里分配的4GB空间是如下分配的：</p>
<ul>
<li>操作系统和所有进程共享使用2GB（类似买房时的公摊面积）</li>
<li>使用进程2GB（被称为用户空间）</li>
</ul>
<p>Linux操作系统中进程占用的内存空间也是4GB，但是用户空间最多可以使用3GB，Windows也可以修改启动参数实现这一点。</p>
<p>使用的Visual Studio 2019编译程序时在默认情况下使用32位模式，即使你安装的是64位CPU操作系统，单个进程的用户空间也不能超过2G。</p>
<p>关于进程使用的2GB用户空间同时也会划分成不同的区段：</p>
<ul>
<li>可执行文件镜像区：存储着可执行文件的镜像，此区域大小取决于可执行文件的大小</li>
<li>动态链接库的映射区：如果程序使用动态链接库，此区域则会装载动态链接库的代码，此区域的大小取决于动态链接库的大小。</li>
<li>栈区：由编译器自动分配和释放，存储函数的参数值，局部变量的值等，Visual Studio中默认为1MB，可以通过链接属性改变。</li>
<li>堆区：程序员可以自行分配和释放的内存区域（Windows下的32位应用程序一般不能超过1.6G）。</li>
<li>保留区：保留区是一块不允许被访问的内存，任何对保留区内存的读写都会引起程序的崩溃（比如内存地址为0，对应的即使保留区，空指针赋值为就是让指针指向保留区的一个地址）</li>
</ul>
<p>动态链接库和静态链接库的区别：</p>
<ul>
<li>程序编译时，动态链接库的代码不会链接到可执行文件内，相反，静态链接库的代码则会被链接到可执行文件内。<br><img src="1.png"></li>
</ul>
<h4 id="计算机内存的计量单位"><a href="#计算机内存的计量单位" class="headerlink" title="计算机内存的计量单位"></a>计算机内存的计量单位</h4><p>在计算机的内存中最小的单位是“位(bit)”，表示二进制的位，一个二进制只能表达”0”和”1”。一个字节（Byte）等于<code>8</code>位。字节是数据数量的基本单位，分配的内存最小单位是1字节。<br>使用”千字节”表示更大的内存空间，<code>1000</code>字节(kB)多用于表示硬盘容量、闪存容量时的计算。而第二种”千字节”是程序员更认可的<code>1024</code>字节，<code>1024</code> 等于 <code>2的十次方</code>，同时1024字节等于1KB。</p>
<ul>
<li>1024KB == 1MB（Megabyte）</li>
<li>1024MB == 1GB（Gigabyte）</li>
<li>1024GB == 1TB（Tara-byte）</li>
<li>1024TB == 1PB（Peta-byte）</li>
</ul>
<h4 id="使用指针进行内存分配注意事项"><a href="#使用指针进行内存分配注意事项" class="headerlink" title="使用指针进行内存分配注意事项"></a>使用指针进行内存分配注意事项</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-comment">// 如果在声明指针变量时无法确定指针变量的值，作为习惯，我们将其设置位空指针 NULL</span><br>  <span class="hljs-comment">// *ptr = &#x27;A&#x27;;     // 引发了异常: 写入访问权限冲突。ptr 是 nullptr</span><br><br>  <span class="hljs-keyword">char</span>* ptr_c = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>  <span class="hljs-comment">// 为什么malloc() 函数要返回void* 类型的指针，为什么要进行强制类型转换</span><br>  <span class="hljs-comment">// 便于程序员根据自己的需要，进项类型转换</span><br><br>  <span class="hljs-comment">// 指针为什么要分成多种类型？不同类型的指针变量所占用的内存空间是一样的吗？</span><br>  <span class="hljs-keyword">int</span>* ptr_a = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">float</span>* ptr_f = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">double</span>* ptr_d = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  %d  %d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(ptr_a), <span class="hljs-keyword">sizeof</span>(ptr_f), <span class="hljs-keyword">sizeof</span>(ptr_d));<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  输出结果：</span><br><span class="hljs-comment">  4    4    4</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义字符串长度函数"><a href="#自定义字符串长度函数" class="headerlink" title="自定义字符串长度函数"></a>自定义字符串长度函数</h4><p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义LengthOfString函数用于计算字符串中字符的个数（字符的长度），</span><br><span class="hljs-comment">参数为字符串常量的首地址，返回值为字符的个数（不含&#x27;\0&#x27;）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">计算字符串的长度：</span><br><span class="hljs-comment">在该函数中，没有通过该指针改变字符串内容的意图，</span><br><span class="hljs-comment">为了防止通过该指针影响字符串的内容，可以在char* 前面添加const限定符</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LengthOfString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// *str = &#x27;A&#x27;;</span><br>  <span class="hljs-comment">// 表达式必须是可修改的左值</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  使用断言防止空指针</span><br><span class="hljs-comment">  在C语言中，可以使用断言assert()来确保某个条件成立，只有在条件成立的情况下，才能该程序继续运行</span><br><span class="hljs-comment">  */</span><br>  assert(str != <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">// 对于计数类的程序，一般都是声明一个整型变量来存储返回值</span><br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 保存输入的字符串长度</span><br>  <span class="hljs-keyword">while</span> (*str++ != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>  &#123;<br>    result++;<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  while()语句本质上只能控制一条语句的循环</span><br><span class="hljs-comment">  但是，一对大括号包含的若干条语句被称为语句块，</span><br><span class="hljs-comment">  语句块可以被while当作一条语句</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* ptr = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配成功\r\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ptr);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    sacnf() 函数</span><br><span class="hljs-comment">    参数1：用字符串常量表示的输入格式字符串</span><br><span class="hljs-comment">    参数2：用户输入的数据送到的目标地址</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// scanf_s(&quot;%s&quot;, ptr);</span><br>    <span class="hljs-comment">// ptr = NULL;</span><br>    <span class="hljs-comment">// 调用断言，会强制程序终止</span><br>    <span class="hljs-keyword">int</span> len = LengthOfString(ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, len);<br>   &#125;<br>  <span class="hljs-built_in">free</span>(ptr);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义字符串复制函数"><a href="#自定义字符串复制函数" class="headerlink" title="自定义字符串复制函数"></a>自定义字符串复制函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下：</span><br><span class="hljs-comment">void stringCopy(char* dest, const char* source)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source)</span></span>;  <span class="hljs-comment">// 函数声明，模拟strcpy()函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* ptr_a = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 申请1024字节的内存空间，并将该块内存的首地址指向ptr_a</span><br>  <span class="hljs-keyword">char</span>* ptr_b = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 申请1024字节的内存空间，并将该块内存的首地址指向ptr_b</span><br>  <span class="hljs-keyword">if</span> (ptr_b == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存空间申请失败!\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存空间申请成功!\r\n&quot;</span>);<br>   <span class="hljs-keyword">int</span> count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ptr_a);<br>   StringCopy(ptr_a, ptr_b);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;运行程序后ptr_a指向的内存空间存储的字符串为：%s&quot;</span>, ptr_a);<br>  &#125;<br>  <span class="hljs-built_in">free</span>(ptr_a); <span class="hljs-comment">// 释放内存</span><br>  <span class="hljs-built_in">free</span>(ptr_b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// *dest = *source; // 当复制一个字符时，可以直接这样使用</span><br>  <span class="hljs-comment">// 当复制多个字符的时候，使用下面的while循环</span><br>  <span class="hljs-keyword">while</span> (*source != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>  &#123;<br>   *dest = *source;<br>   dest++;<br>   source++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在输入字符串按下回车后，会显示屯屯屯屯屯屯屯屯屯···<br><img src="2.png"></p>
<p>在Visual Studio的调试模式下malloc()函数会自动往申请的空间内填写内容，至于填写的内容转换成中文编就是屯屯屯屯屯屯···</p>
<p><strong>解决 “屯屯屯屯···” 问题:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 添加while循环条件 *dest = &#x27;\0&#x27;</span><br><span class="hljs-keyword">while</span> (*dest = <span class="hljs-string">&#x27;\0&#x27;</span> || *source != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br>  *dest = *source;<br>  dest++;<br>  source++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="EasyX的简单使用"><a href="#EasyX的简单使用" class="headerlink" title="EasyX的简单使用"></a>EasyX的简单使用</h4><p>去[EasyX](https:// easyx.cn/downloads/)官网下载最新的EasyX库的安装程序，下载后双击打开，<code>EasyX</code>库安装程序会自动检测当前计算机使用的<code>IDE(Integrated Development Environment)</code>版本，然后点击安装即可在对应的<code>IDE</code>中添加<code>EasyX</code>头文件和库文件。安装速度很快，完成后就可以在<code>IDE</code>中添加 <code>graphics.h</code>头文件进行使用。<br><img src="3.png"></p>
<p><strong>EaxyX库函数的简单使用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  initgraph(<span class="hljs-number">600</span>,<span class="hljs-number">500</span>);     <span class="hljs-comment">// 创建绘图窗口，大小为600x500像素</span><br>    <br>  putpixel(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 使用putpixel()函数生成1像素点，三个参数，参数1为点的X轴坐标，参数2为点的Y轴坐标，参数3为点的颜色</span><br>  circle(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>);   <span class="hljs-comment">// 使用circle()函数 画圆圈，圆心坐标（200，200），半径100</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">200</span>; x &lt;= <span class="hljs-number">350</span>; x++)<br>  &#123;<br>   putpixel(x, <span class="hljs-number">200</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br>   <span class="hljs-comment">// 同样在使用putpixel()函数的基础上，就可以使用for()循环输出多个相连续的点，也就是一条直线</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">200</span>; y &lt;= <span class="hljs-number">350</span>; y++)<br>  &#123;<br>   putpixel(<span class="hljs-number">200</span>, y, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  &#125;<br>  _getch();      <span class="hljs-comment">// 按任意键继续</span><br>  closegraph();    <span class="hljs-comment">// 关闭绘图窗口</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>运行程序后的结果：</strong><br><img src="4.png"></p>
<h4 id="习题练习："><a href="#习题练习：" class="headerlink" title="习题练习："></a>习题练习：</h4><h3 id="1、完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下："><a href="#1、完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下：" class="headerlink" title="1、完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下："></a>1、完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stringCopy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source)</span></span>;<br></code></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">完成stringCopy函数，实现与函数strcpy同样的功能，函数原型如下：</span><br><span class="hljs-comment">void stringCopy(char* dest, const char* source)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* ptr_a = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">char</span>* ptr_b = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">if</span> (ptr_a == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存空间申请失败!\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存空间申请成功!\r\n&quot;</span>);<br>   <span class="hljs-keyword">int</span> count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ptr_b);<br>   StringCopy(ptr_a, ptr_b);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;运行程序后ptr_a指向的内存空间存储的字符串为：%s&quot;</span>, ptr_a);<br>  &#125;<br>  <span class="hljs-built_in">free</span>(ptr_a);<br>  <span class="hljs-built_in">free</span>(ptr_b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// *dest = *source; // 当复制一个字符时，可以直接这样使用</span><br>  <span class="hljs-keyword">while</span> (*dest = <span class="hljs-string">&#x27;\0&#x27;</span> || *source != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>  &#123;<br>  *dest = *source;<br>  dest++;<br>  source++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2、完成drawBox函数，实现在屏幕指定位置绘制指定大小、颜色的矩形功能，函数原型如下："><a href="#2、完成drawBox函数，实现在屏幕指定位置绘制指定大小、颜色的矩形功能，函数原型如下：" class="headerlink" title="2、完成drawBox函数，实现在屏幕指定位置绘制指定大小、颜色的矩形功能，函数原型如下："></a>2、完成drawBox函数，实现在屏幕指定位置绘制指定大小、颜色的矩形功能，函数原型如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> borderColor, <span class="hljs-keyword">int</span> borderWidth, <span class="hljs-keyword">int</span> fillColor)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-function"><span class="hljs-comment">int top;   // 要生成图像的左上角坐标的开始点（距离生成的绘制框顶部边框的距离）</span></span><br><span class="hljs-function"><span class="hljs-comment">int left;  // 要生成图像的左上角坐标的开始点（距离生成的绘制框左侧边框的距离）</span></span><br><span class="hljs-function"><span class="hljs-comment">int width;  // 要生成的最外图形的边框长度</span></span><br><span class="hljs-function"><span class="hljs-comment">int hieght; // 要生成的最外图形的边框高度</span></span><br><span class="hljs-function"><span class="hljs-comment">int borderColor;   // 要生成的最外图形背景色</span></span><br><span class="hljs-function"><span class="hljs-comment">int borderWidth;   // 生成嵌套图形间的高度差</span></span><br><span class="hljs-function"><span class="hljs-comment">int fillColor;    // 要生成的嵌套图形背景色</span></span><br><span class="hljs-function"><span class="hljs-comment">*/</span></span><br></code></pre></td></tr></table></figure>
<p><strong>问题分析：</strong><br>1、绘制出两个或多个嵌套的四边形，为了区分可以将每个四边形的颜色设置成不一样的<br>2、使用initgraph()函数生成对应大小像素的绘制框，例如：initgraph(640，480);会生成一个640像素x480<br>像素的窗口<br>3、像素点的坐标可以用（x,y）表示，使用<code>putpixel(100, 100, RGB(255, 0, 0));</code> 就会在窗口里生成一个坐标为（100,100）的红色像素点。<br><img src="5.png"></p>
<p>4、画图可以帮助我们快速理解问题的具体需求，点会画了，线也就好画了。在代码中可以先使用几对临时数据帮助我们更快的解决问题。废话不多说，上代码。<br><img src="6.png"></p>
<p><img src="7.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 为了方便我们需要声明并定义两个函数用来快速生成对应颜色的像素线</span><br><span class="hljs-comment">// 垂直线，X轴不变</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数意思：</span><br><span class="hljs-comment">int x;       垂直打印连续的像素点，每个点的X轴坐标是固定的，该变量的值为像素点开始的X轴坐标</span><br><span class="hljs-comment">int yStart;    Y轴像素点的开始位置</span><br><span class="hljs-comment">int yEnd;     Y轴像素点的结束位置</span><br><span class="hljs-comment">int color;    生成连续像素点的颜色</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VerticalLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> yStart, <span class="hljs-keyword">int</span> yEnd, <span class="hljs-keyword">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = yStart; y &lt;= yEnd; y++)<br>  &#123;<br>    putpixel(x, y, color);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 水平线，y轴不变</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数意思：</span><br><span class="hljs-comment">int y;       水平打印连续的像素点，每个点的Y轴坐标是固定的，该变量的值为像素点开始的Y轴坐标</span><br><span class="hljs-comment">int xStart;    Y轴像素点的开始位置</span><br><span class="hljs-comment">int xEnd;     Y轴像素点的结束位置</span><br><span class="hljs-comment">int color;    生成连续像素点的颜色</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xStart, <span class="hljs-keyword">int</span> xEnd, <span class="hljs-keyword">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = xStart; x &lt;= xEnd; x++)<br>  &#123;<br>    putpixel(x, y, color);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Veision：1 输入固定参数，显示对应的图形</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在函数drawBox()中调用 void verticalLine()、void levelLine()即可生成对应颜色的四边形</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> left,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> width,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> height,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> borderColor,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> borderWidth,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> fillColor)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 最外侧四边形的两条上下线的起始点，结束点及颜色</span><br>  VerticalLine(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  VerticalLine(<span class="hljs-number">600</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 中间四边形的两条上下线的起始点，结束点及颜色</span><br>  VerticalLine(<span class="hljs-number">120</span>, <span class="hljs-number">120</span>, <span class="hljs-number">380</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br>  VerticalLine(<span class="hljs-number">580</span>, <span class="hljs-number">120</span>, <span class="hljs-number">380</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 最内层四边形的两条上下线的起始点，结束点及颜色</span><br>  VerticalLine(<span class="hljs-number">140</span>, <span class="hljs-number">140</span>, <span class="hljs-number">360</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  VerticalLine(<span class="hljs-number">560</span>, <span class="hljs-number">140</span>, <span class="hljs-number">360</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br><br>  <span class="hljs-comment">// 最外侧四边形的两条左右线的起始点，结束点及颜色</span><br>  LevelLine(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">600</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <br>  LevelLine(<span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">600</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 中间四边形的两条左右线的起始点，结束点及颜色</span><br>  LevelLine(<span class="hljs-number">120</span>, <span class="hljs-number">120</span>, <span class="hljs-number">580</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br>  LevelLine(<span class="hljs-number">380</span>, <span class="hljs-number">120</span>, <span class="hljs-number">580</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 最内层四边形的两条左右线的起始点，结束点及颜色</span><br>  LevelLine(<span class="hljs-number">140</span>, <span class="hljs-number">140</span>, <span class="hljs-number">560</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  LevelLine(<span class="hljs-number">360</span>, <span class="hljs-number">140</span>, <span class="hljs-number">560</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>运行代码效果图如下：</strong><br><img src="8.png"></p>
<p><strong>Version 2：使用for()循环简化上一步的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 如上图所示，该for()循环将实现最外侧的四边形，并进行填充对应的色彩</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">100</span>; x &lt;= <span class="hljs-number">400</span>; x++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">100</span>; y &lt;= <span class="hljs-number">260</span>; y++)<br>  &#123;<br>    VerticalLine(x, y, <span class="hljs-number">260</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 如上图所示，该for()循环将实现中间的四边形，并进行填充对应的色彩</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">110</span>; y &lt;= <span class="hljs-number">390</span>; y++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">110</span>; x &lt;= <span class="hljs-number">250</span>; x++)<br>  &#123;<br>   LevelLine(x, y, <span class="hljs-number">390</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br>  &#125;<br> &#125;<br><span class="hljs-comment">// 如上图所示，该for()循环将实现最内侧的四边形，并进行填充对应的色彩</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">120</span>; y &lt;= <span class="hljs-number">380</span>; y++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">120</span>; x &lt;= <span class="hljs-number">240</span>; x++)<br>  &#123;<br>   LevelLine(x, y, <span class="hljs-number">380</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>运行代码后的效果如下：</strong><br><img src="9.png"></p>
<p><strong>Version 迭代版：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">为了实现在屏幕指定位置绘制指定大小、颜色的矩形功能，</span><br><span class="hljs-comment">由于上面的代码是传输的具体值，和题意不符，所以话需要进一步改进代码。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> wigth, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> borderColor, <span class="hljs-keyword">int</span> </span></span><br><span class="hljs-function"><span class="hljs-params">borderWidth, <span class="hljs-keyword">int</span> borderWidth2, <span class="hljs-keyword">int</span> fillColor, <span class="hljs-keyword">int</span> fillColor2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 打印最外侧层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = top; x &lt;= wigth; x++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = left; y &lt;= height; y++)<br>    &#123;<br>      VerticalLine(x, y, height, borderColor);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 打印中间层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = top + borderWidth; y &lt;= wigth - borderWidth; y++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = left + borderWidth; x &lt;= height - borderWidth; x++)<br>    &#123;<br>      LevelLine(x, y, wigth - borderWidth, fillColor);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-comment">// 打印最内层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = top + borderWidth + borderWidth2; <br>    y &lt;= wigth - borderWidth - borderWidth2; <br>    y++)<br>  &#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = left + borderWidth + borderWidth2;<br>    x &lt;= height - borderWidth - borderWidth2;<br>    x++)<br>   &#123;<br>    LevelLine(x, y, wigth - borderWidth- borderWidth2, fillColor2);<br>   &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>最后贴上完整的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VerticalLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> yStart, <span class="hljs-keyword">int</span> yEnd, <span class="hljs-keyword">int</span> color)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xStart, <span class="hljs-keyword">int</span> xEnd, <span class="hljs-keyword">int</span> color)</span></span>;<br><span class="hljs-comment">// 该函数实现的三个嵌套的四边形</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> wigth, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> borderColor, <span class="hljs-keyword">int</span> </span></span><br><span class="hljs-function"><span class="hljs-params">borderWidth, <span class="hljs-keyword">int</span> borderWidth2, <span class="hljs-keyword">int</span> fillColor, <span class="hljs-keyword">int</span> fillColor2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  initgraph(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);<span class="hljs-comment">// 窗口大小</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  调用drawBox()函数，在800像素x600像素的窗口内会绘制一个100像素x100像素的正方形</span><br><span class="hljs-comment">  绘制的图形边框颜色为红色( RGB(255, 0, 0) )，图形的边框宽度为10像素</span><br><span class="hljs-comment">  绘制的图形内部（不包括边框）颜色为蓝色( RGB(0, 0, 255) )</span><br><span class="hljs-comment">  */</span><br>  drawBox(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">260</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>),RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>  _getch();         <span class="hljs-comment">// 防止生成的绘图窗口一闪而过</span><br>  closegraph();     <span class="hljs-comment">// 关闭绘图窗口</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 垂直线，X轴不变</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VerticalLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> yStart, <span class="hljs-keyword">int</span> yEnd, <span class="hljs-keyword">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = yStart; y &lt;= yEnd; y++)<br>  &#123;<br>   putpixel(x, y, color);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 水平线，y轴不变</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xStart, <span class="hljs-keyword">int</span> xEnd, <span class="hljs-keyword">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = xStart; x &lt;= xEnd; x++)<br>  &#123;<br>   putpixel(x, y, color);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// drawBox()函数定义</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBox</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> wigth, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> borderColor, <span class="hljs-keyword">int</span> </span></span><br><span class="hljs-function"><span class="hljs-params">borderWidth, <span class="hljs-keyword">int</span> borderWidth2, <span class="hljs-keyword">int</span> fillColor, <span class="hljs-keyword">int</span> fillColor2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 打印最外侧层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = top; x &lt;= wigth; x++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = left; y &lt;= height; y++)<br>    &#123;<br>      VerticalLine(x, y, height, borderColor);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 打印中间层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = top + borderWidth; y &lt;= wigth - borderWidth; y++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = left + borderWidth; x &lt;= height - borderWidth; x++)<br>    &#123;<br>      LevelLine(x, y, wigth - borderWidth, fillColor);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-comment">// 打印最内层图形</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = top + borderWidth + borderWidth2; y &lt;= wigth - borderWidth - borderWidth2; y++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = left + borderWidth + borderWidth2; x &lt;= height - borderWidth - borderWidth2; x++)<br>    &#123;<br>      LevelLine(x, y, wigth - borderWidth- borderWidth2, fillColor2);<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>main()函数中调用drawBox()函数，<code>drawBox(100, 100, 300, 260, RGB(255, 0, 0), 10, 10, RGB(0, 255, 0),RGB(0, 0, 255));</code> drawBos()函数里的参数是可以替换的，这里的意思是<code>initgraph(650, 500);// 窗口大小</code>会在650像素x500像素的窗口显示三个嵌套的四边形，最外侧的四边形左上角的坐标为(100像素，100像素)，最外侧的四边形长度为300像素，宽度为260像素，图形的填充色为红色，中间层图形和最外侧图形的边距少10像素，填充色为绿色，最内层的图形和中间层的图形边距少10像素，填充色为蓝色。</p>
<p><strong>运行代码后的效果如下所示：</strong></p>
<p><img src="10.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
        <tag>EasyX图形库</tag>
      </tags>
  </entry>
  <entry>
    <title>跨语言插件的编写以及使用</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<h3 id="插件的使用代码封装"><a href="#插件的使用代码封装" class="headerlink" title="插件的使用代码封装"></a>插件的使用代码封装</h3><p>插件使用的步骤：</p>
<ul>
<li>查询注册表</li>
<li>加载导出函数</li>
<li>产生类工厂</li>
<li>产生对象</li>
</ul>
<p>每次使用插件前几步操作需要重复，所以可以对其进行封装，方便下次使用，代码实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Use.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyInterface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;oleauto.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;comdef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;atlbase.h&gt;</span></span><br><span class="hljs-function">HRESULT __stdcall <span class="hljs-title">MyGetClassObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GUID&amp; clsid, <span class="hljs-keyword">const</span> GUID&amp; IID, <span class="hljs-keyword">void</span>** ppObject)</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> szKey[MAX_PATH];<br>  <span class="hljs-comment">//&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;</span><br>  wsprintf(szKey, <br>  <span class="hljs-string">&quot;CLSID\\&#123;%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X&#125;\\InprocServer32&quot;</span>, <br>  clsid.Data1, clsid.Data2, clsid.Data3, <br>  clsid.Data4[<span class="hljs-number">0</span>], clsid.Data4[<span class="hljs-number">1</span>], clsid.Data4[<span class="hljs-number">2</span>], <br>  clsid.Data4[<span class="hljs-number">3</span>], clsid.Data4[<span class="hljs-number">4</span>], clsid.Data4[<span class="hljs-number">5</span>], <br>  clsid.Data4[<span class="hljs-number">6</span>], clsid.Data4[<span class="hljs-number">7</span>]);<br>  <span class="hljs-comment">//1. 查询注册表</span><br>  <span class="hljs-keyword">char</span> szPath[MAX_PATH];<br>  LONG nLen = <span class="hljs-keyword">sizeof</span>(szPath);<br>  HKEY hKey;<br>  RegOpenKey(HKEY_CLASSES_ROOT, szKey, &amp;hKey);<br>  RegQueryValue(hKey, <span class="hljs-literal">NULL</span>, szPath, &amp;nLen);<br>  RegCloseKey(hKey);<br>  <span class="hljs-comment">//2.加载</span><br>  HMODULE hDll = LoadLibrary(szPath);<br>  <span class="hljs-keyword">if</span> (hDll == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> S_FALSE;<br>  MY_GET_CLASS_OBJECT pfnGetClassObj = <br>  (MY_GET_CLASS_OBJECT)GetProcAddress(hDll, <span class="hljs-string">&quot;DllGetClassObject&quot;</span>);<br>  <span class="hljs-keyword">if</span> (pfnGetClassObj == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> S_FALSE;<br>  <span class="hljs-keyword">return</span> (*pfnGetClassObj)(clsid, IID, ppObject);<br>&#125;<br><span class="hljs-function">HRESULT __stdcall <span class="hljs-title">MyCreateObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GUID&amp; clsid, <span class="hljs-keyword">const</span> GUID&amp; IID, <span class="hljs-keyword">void</span>** ppObject)</span> </span>&#123;<br>  IMyFactory* pFactory = <span class="hljs-literal">NULL</span>;<br>  HRESULT hr = MyGetClassObject(clsid, IID_IMyFactory, (<span class="hljs-keyword">void</span>**)&amp; pFactory);<br>  <span class="hljs-keyword">if</span> (FAILED(hr)) &#123;<br>    <span class="hljs-keyword">return</span> hr;<br>  &#125;<br>  hr = pFactory-&gt;CreateObj(IID, ppObject);<br>  pFactory-&gt;Release();<br>  <span class="hljs-keyword">return</span> hr;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TYPE&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CMyPtr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  CMyPtr(TYPE* pObject = <span class="hljs-literal">NULL</span>) &#123;<br>    m_pObject = pObject;<br>  &#125;<br>  ~CMyPtr() &#123;<br>    <span class="hljs-keyword">if</span> (m_pObject != <span class="hljs-literal">NULL</span>) &#123;<br>      m_pObject-&gt;Release();<br>      m_pObject = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  &#125;<br>  TYPE* <span class="hljs-keyword">operator</span>-&gt; () &#123;<br>    <span class="hljs-keyword">return</span> m_pObject;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  TYPE* m_pObject;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//.TLB(typelib)   接口定义语言  ==&gt;  编译 ==&gt; TLB </span><br>  CMyPtr&lt;ISuperMath&gt; pSuperMath = <span class="hljs-literal">NULL</span>;<br>  HRESULT hr = MyCreateObject(CLSID_CSuperMath, IID_ISuperMath, (<span class="hljs-keyword">void</span>**)&amp;pSuperMath);<br>  <span class="hljs-keyword">if</span> (FAILED(hr)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">long</span> ret;<br>  pSuperMath-&gt;Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &amp;ret);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1+2=%d\n&quot;</span>, ret);<br>  <span class="hljs-comment">//pSuperMath-&gt;Release();</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用智能指针将使用插件代码再次进行精简，不需要手动释放。</p>
<p>接口头文件的类中不写虚析构是为了使生成的虚表统一。</p>
<h3 id="接口统一规范"><a href="#接口统一规范" class="headerlink" title="接口统一规范"></a>接口统一规范</h3><p>接口头文件各个语言使用时不一致，方便各个语言都支持使用，使用微软定义的新头文件格式（二进制形式（没有语法格式））：<strong>TLB</strong>（typelib）文件（C++、C都认识）。</p>
<p>接口定义语言 –&gt; 通过编译器（<strong>midl</strong>）进行编译 –&gt; TLB文件</p>
<p>新建文件（**.idl** 结尾），使用实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unknwn.idl&quot;</span>;<br>[<br>    object, <span class="hljs-comment">// 表示该插件是本地的插件，不是远程的</span><br>    uuid&#123;&#125;  <span class="hljs-comment">// 插件的GUID</span><br>]<br>interface ISuperMath : <span class="hljs-keyword">public</span> IUnKnow<br>&#123;<br>    [helpstring(<span class="hljs-string">&quot;加法运算&quot;</span>)] <span class="hljs-comment">// 方法注释 </span><br>    <span class="hljs-function">HRESULT <span class="hljs-title">Add</span><span class="hljs-params">([<span class="hljs-keyword">int</span>]<span class="hljs-keyword">long</span> n1, [<span class="hljs-keyword">int</span>]<span class="hljs-keyword">long</span> n2, [out, retval]<span class="hljs-keyword">long</span>* result)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>方法的调用约定不需要写，基类 <strong>IUnKnow</strong>（微软标准的基类）的定义在头文件 “<strong>unknow.idl</strong>“ 中。**.idl** 语法支持在所有的函数方法前添加一个属性，属性使用 “<strong>[]</strong>“ 号包着。</p>
<p>使用 编译器（<strong>midl</strong>）对其进行编译，操作示例：<br><img src="1.png"><br><img src="2.png"><br><img src="3.png"></p>
<blockquote>
<p>上述的操作，生成的文件依然是供 C、C++ 使用的。</p>
</blockquote>
<p>将 <strong>.idl</strong> 文件编译成二进制文件（**.tlb**文件）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unknwn.idl&quot;</span>;<br>[<br>  uuid(<span class="hljs-number">39</span>A61464<span class="hljs-number">-0E8</span>B<span class="hljs-number">-4f</span>66<span class="hljs-number">-941</span>A<span class="hljs-number">-9057229</span>D65C5),   <span class="hljs-comment">// 库的GUID</span><br>  version(<span class="hljs-number">1.0</span>) <span class="hljs-comment">// 插件的版本号</span><br>]<br>library MySuperMathLib<br>&#123;<br>  [<br>    object,<br>    uuid(<span class="hljs-number">581</span>DBB8F-D856<span class="hljs-number">-4735</span>-A9D2-F5B10244CF2B)  <span class="hljs-comment">// 插件的GUID</span><br>  ]<br>  interface ISuperMath : IUnknown<br>  &#123;<br>    [helpstring(<span class="hljs-string">&quot;加法运算&quot;</span>)] <span class="hljs-function">HRESULT <span class="hljs-title">Add</span><span class="hljs-params">([in]<span class="hljs-keyword">long</span> n1, [in]<span class="hljs-keyword">long</span> n2, [out, retval]<span class="hljs-keyword">long</span>* result)</span></span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>操作示例：</p>
<p><img src="4.png"></p>
<p><strong>.idl</strong> 文件编译后 <strong>.h</strong> 文件和 <strong>.tlb</strong> 二进制文件同时存在，代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unknwn.idl&quot;</span>;<br>[<br>  object,<br>  uuid(<span class="hljs-number">581</span>DBB8F-D856<span class="hljs-number">-4735</span>-A9D2-F5B10244CF2B)    <span class="hljs-comment">// 插件的GUID</span><br>]<br>interface ISuperMath : IUnknown<br>&#123;<br>  [helpstring(<span class="hljs-string">&quot;加法运算&quot;</span>)] <span class="hljs-function">HRESULT <span class="hljs-title">Add</span><span class="hljs-params">([in]<span class="hljs-keyword">long</span> n1, [in]<span class="hljs-keyword">long</span> n2, [out, retval]<span class="hljs-keyword">long</span>* result)</span></span>;<br>&#125;;<br>[<br>  uuid(<span class="hljs-number">39</span>A61464<span class="hljs-number">-0E8</span>B<span class="hljs-number">-4f</span>66<span class="hljs-number">-941</span>A<span class="hljs-number">-9057229</span>D65C5),<br>  version(<span class="hljs-number">1.0</span>)<br>]<br>library MySuperMathLib<br>&#123;<br>  interface ISuperMath;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>操作示例：<br><img src="5.png"></p>
<blockquote>
<p>添加类工厂GUID</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unknwn.idl&quot;</span>;<br>[<br>  object,<br>  uuid(<span class="hljs-number">581</span>DBB8F-D856<span class="hljs-number">-4735</span>-A9D2-F5B10244CF2B)<br>]<br>interface ISuperMath : IUnknown<br>&#123;<br>  [helpstring(<span class="hljs-string">&quot;加法运算&quot;</span>)] <span class="hljs-function">HRESULT <span class="hljs-title">Add</span><span class="hljs-params">([in]<span class="hljs-keyword">long</span> n1, [in]<span class="hljs-keyword">long</span> n2, [out, retval]<span class="hljs-keyword">long</span>* result)</span></span>;<br>&#125;;<br>[<br>  uuid(<span class="hljs-number">39</span>A61464<span class="hljs-number">-0E8</span>B<span class="hljs-number">-4f</span>66<span class="hljs-number">-941</span>A<span class="hljs-number">-9057229</span>D65C5),<br>  version(<span class="hljs-number">1.0</span>)<br>]<br>library MySuperMathLib<br>&#123;<br>  [<br>    uuid(FE5955E8-B3C2<span class="hljs-number">-4</span>a1d<span class="hljs-number">-8B</span>46-B24CDF5F2808)  <span class="hljs-comment">// 类工厂的GUID</span><br>  ]<br>  coclass CSuperMath<br>  &#123;<br>    interface ISuperMath;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>xxx_i.c 文件内保存了库、接口、类工厂的GUID：<br><img src="6.png"></p>
</blockquote>
<h4 id="使用VS自动编译-idl-文件"><a href="#使用VS自动编译-idl-文件" class="headerlink" title="使用VS自动编译 .idl 文件"></a>使用VS自动编译 .idl 文件</h4><p>创建一个动态链接库，将 “<strong>..idl</strong>“ 文件导入到工程中，按 “<strong>F7</strong>“ 键 编译即可，操作如下：<br><img src="7.png"><br><img src="8.png"><br><img src="9.png"></p>
<h4 id="插件接口功能的实现"><a href="#插件接口功能的实现" class="headerlink" title="插件接口功能的实现"></a>插件接口功能的实现</h4><p>需要开发者自己 new 一个类，包含头文件（C、C++），继承接口类即可，操作如下：</p>
<ul>
<li>在动态链接库中 new 一个类 –&gt; “<strong>CSuperMath</strong>“ 继承 “<strong>ISuperMath</strong>“。</li>
<li>包含编译 “<strong>.idl</strong>“ 文件后生成的头文件 –&gt; “<strong>ISuperMath_h.h</strong>“。</li>
<li>将编译 “<strong>.idl</strong>“ 文件后生成的 “<strong>ISuperMath_i.c</strong>“ 文件添加到工程中。</li>
<li>添加接口对应的类工厂 –&gt; “<strong>CSuperMathFactory</strong>“。</li>
<li>添加的类工厂需要继承微软官方的基类 –&gt; “<strong>IClassFactory</strong>“ 实现类工厂。</li>
<li>在 “<strong>dllmain.cpp</strong>“ 中实现 “<strong>DllGetClassObject</strong>、<strong>DllCanUnloadNow</strong>、<strong>DllRegisterServer</strong>、<strong>DllUnregisterServer</strong>“ 四个导出函数，并导出。</li>
<li>不使用预编译头，编译程序。</li>
<li>编译成功后，使用 <code>dumpbin /EXPORTS SuperMath.dll</code> 命令查看导出函数是否导出。</li>
<li>导出函数导出后，将其 “<strong>SuperMath.dll</strong>“ 插件使用 “<strong>regsvr32.exe</strong>“ 将其写入到注册表中。</li>
<li>插件写入注册表成功后，就可以使用。</li>
</ul>
<p>查看导出函数：</p>
<p><img src="10.png"></p>
<p>插件注册：</p>
<p><img src="11.png"></p>
<p>“dllmain.cpp” 代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CSuperMathFactory.h&quot;</span></span><br>HMODULE g_hModule;<br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  HMODULE hModule,</span></span><br><span class="hljs-function"><span class="hljs-params">  DWORD  ul_reason_for_call,</span></span><br><span class="hljs-function"><span class="hljs-params">  LPVOID lpReserved)</span></span><br><span class="hljs-function"></span>&#123;<br>  g_hModule = hModule;<br>  <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>  &#123;<br>  <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>  <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>  <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>  <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-comment">//DllGetClassObject</span><br><span class="hljs-function">HRESULT __stdcall <span class="hljs-title">DllGetClassObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GUID&amp; clsid, <span class="hljs-keyword">const</span> GUID&amp; iid, <span class="hljs-keyword">void</span>** ppObject)</span> </span>&#123;<br>  <span class="hljs-comment">//判断创建哪个类工厂</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(&amp;clsid, &amp;CLSID_CSuperMath, <span class="hljs-keyword">sizeof</span>(GUID)) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">static</span> CSuperMathFactory* pObject = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (pObject == <span class="hljs-literal">NULL</span>) &#123;<br>      pObject = <span class="hljs-keyword">new</span> CSuperMathFactory();<br>    &#125;<br>    HRESULT hr = pObject-&gt;QueryInterface(iid, ppObject);<br>    <span class="hljs-keyword">if</span> (FAILED(hr) &amp;&amp; CSuperMathFactory::m_nRefCount == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> pObject;<br>      pObject = <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-keyword">return</span> hr;<br>    &#125;<br>    *ppObject = pObject;<br>    <span class="hljs-keyword">return</span> hr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> E_NOINTERFACE;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* g_szRegTable[][<span class="hljs-number">3</span>] =<br>&#123;<br>  &#123;<br>    <span class="hljs-string">&quot;CLSID\\&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;MySuperMath&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;CLSID\\&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;\\InprocServer32&quot;</span>, <span class="hljs-number">0</span>,(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)<span class="hljs-number">-1</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;CLSID\\&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;\\ProgID&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;MySuperMathsrv.1&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;CLSID\\&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;\\TypeLib&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;MySuperMathsrv.1&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;MySuperMath&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;MySuperMathsrv.1\\CLSID&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&#123;FE5955E8-B3C2-4a1d-8B46-B24CDF5F2808&#125;&quot;</span><br>  &#125;,<br>&#125;;<br><span class="hljs-comment">//是否能卸载</span><br><span class="hljs-function">STDAPI <span class="hljs-title">DllCanUnloadNow</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> S_OK;<br>&#125;<br><span class="hljs-comment">//安装</span><br><span class="hljs-function">STDAPI <span class="hljs-title">DllRegisterServer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> szBuf[MAX_PATH];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(g_szRegTable) / <span class="hljs-keyword">sizeof</span>(g_szRegTable[<span class="hljs-number">0</span>]); i++) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszSubKey = g_szRegTable[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszValueName = g_szRegTable[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszValue = g_szRegTable[i][<span class="hljs-number">2</span>];<br>    HKEY hKey;<br>    RegCreateKey(HKEY_CLASSES_ROOT, pszSubKey, &amp;hKey);<br>    <span class="hljs-keyword">if</span> (pszValue == (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)<span class="hljs-number">-1</span>) &#123;<br>      GetModuleFileName(g_hModule, szBuf, <span class="hljs-keyword">sizeof</span>(szBuf));<br>      pszValue = szBuf;<br>    &#125;<br>    RegSetValueEx(hKey, pszValueName, <span class="hljs-literal">NULL</span>, REG_SZ, (CONST BYTE*)pszValue, <span class="hljs-built_in">strlen</span>(pszValue));<br>  &#125;<br>  <span class="hljs-keyword">return</span> S_OK;<br>&#125;<br><span class="hljs-comment">//卸载</span><br><span class="hljs-function">STDAPI <span class="hljs-title">DllUnregisterServer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-keyword">sizeof</span>(g_szRegTable) / <span class="hljs-keyword">sizeof</span>(g_szRegTable[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszSubKey = g_szRegTable[i][<span class="hljs-number">0</span>];<br>    RegDeleteKey(HKEY_CLASSES_ROOT, pszSubKey);<br>  &#125;<br>  <span class="hljs-keyword">return</span> S_OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="插件接口功能的使用"><a href="#插件接口功能的使用" class="headerlink" title="插件接口功能的使用"></a>插件接口功能的使用</h4><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><ul>
<li>创建对应的工程文件使用即可（这里以.cpp为例）</li>
<li>使用微软提供的API：<br><strong>CoInitialize</strong> –&gt; 初始化<br><strong>CoUnInitialize</strong> –&gt; 反初始化<br><strong>CoGetClassObject</strong> –&gt; 自动查询注册表</li>
<li>接口的GUID在编译 “<strong>.idl</strong>“ 文件后生成的头文件 –&gt; “<strong>ISuperMath_h.h</strong>“ 中，将其和 “<strong>ISuperMath_i.c</strong>“ 文件以同拷贝到使用插件的工程中</li>
</ul>
<blockquote>
<p>方法1，代码示例：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// CppTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ISuperMath_h.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  CoInitialize(<span class="hljs-literal">NULL</span>);<br>  IClassFactory* pFactory = <span class="hljs-literal">NULL</span>;<br>  HRESULT hr = CoGetClassObject(<br>    CLSID_CSuperMath, CLSCTX_INPROC_SERVER,<br>    <span class="hljs-literal">NULL</span>, IID_IClassFactory, (<span class="hljs-keyword">void</span>**)pFactory);<br>  <span class="hljs-keyword">if</span> (FAILED(hr))<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  ISuperMath* pSuperMath = <span class="hljs-literal">NULL</span>;<br>  pFactory-&gt;CreateInstance(<span class="hljs-literal">NULL</span>, IID_ISuperMath, (<span class="hljs-keyword">void</span>**)&amp;pSuperMath);<br>  <span class="hljs-keyword">long</span> nRet = <span class="hljs-number">0</span>;<br>  pSuperMath-&gt;Add(<span class="hljs-number">999</span>, <span class="hljs-number">1</span>, &amp;nRet);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;999 + 1 = %d\n&quot;</span>, nRet);<br>  pSuperMath-&gt;Sub(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;nRet);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;20 - 10 = %d\n&quot;</span>, nRet);<br>  CoUninitialize();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>方法2，使用 <code>CoCreateInstance</code>  直接产生对象（产生多个对象的时候这个函数不能使用），代码示例：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// CppTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ISuperMath_h.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  CoInitialize(<span class="hljs-literal">NULL</span>);<br>  ISuperMath* pSuperMath = <span class="hljs-literal">NULL</span>;<br>  CoCreateInstance(CLSID_CSuperMath, <br>    <span class="hljs-literal">NULL</span>, CLSCTX_INPROC_SERVER, <br>    IID_ISuperMath, (<span class="hljs-keyword">void</span>**)&amp;pSuperMath);<br>  <span class="hljs-keyword">long</span> nRet = <span class="hljs-number">0</span>;<br>  pSuperMath-&gt;Add(<span class="hljs-number">999</span>, <span class="hljs-number">1</span>, &amp;nRet);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;999 + 1 = %d\n&quot;</span>, nRet);<br>  pSuperMath-&gt;Sub(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;nRet);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;20 - 10 = %d\n&quot;</span>, nRet);<br>  CoUninitialize();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>``` <br><br>##### VB<br><br>VC <span class="hljs-number">6.0</span> 下新建VB项目，在项目中包含编译 <span class="hljs-string">&quot;**.idl**&quot;</span> 文件后生成的二进制 <span class="hljs-string">&quot;**SuperMath.tlb**&quot;</span> 文件。<br><br>![](<span class="hljs-number">12.</span>png)<br><br>在界面上放置一个按钮控件，双击控件，在对应的方法内使用即可，代码示例：<br>```VB<br><span class="hljs-function">Private Sub <span class="hljs-title">Commandl_Click</span><span class="hljs-params">()</span></span><br>    Dim obj  As New MySuperMathLib.CSuperMath<br>    MsgBox <span class="hljs-string">&quot;1 + 2 = &quot;</span> &amp; obj.Add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<p>注意引用计数的问题。微软官方库在 new 对象的时候，引用计数就加1。<br>脚本语言重新设计的接口，不需要添加头文件。</p>
<h3 id="ATL"><a href="#ATL" class="headerlink" title="ATL"></a>ATL</h3><p>微软提供的框架：<strong>ATL</strong>（activityx Template Library），方便写插件（导出函数，.idl、插件写入注册表等的函数都已进行封装）。自己只需要写接口实现类即可。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>打开VS -&gt; 创建新项目 -&gt; C++ -&gt; ATL 项目：</p>
<p><img src="13.png"><br><img src="14.png"></p>
<h4 id="创建接口类"><a href="#创建接口类" class="headerlink" title="创建接口类"></a>创建接口类</h4><p>解决方案 -&gt; 右键项目名（这里以ATLSuperMath为例）-&gt; 添加 -&gt; 新建项 -&gt; ATL -&gt; “<strong>ATL简单对象</strong>“：</p>
<p><img src="15.png"><br><img src="16.png"></p>
<p><strong>选项 -&gt; 接口：</strong></p>
<ul>
<li><strong>双重</strong>：<code>支持不包含头文件的语言以及需要包含头文件的语言使用插件</code></li>
<li><strong>自定义</strong>：<code>仅支持包含头文件的语言使用插件</code></li>
</ul>
<p><img src="17.png"></p>
<p>创建 “<strong>ATL 简单对象</strong>“ 完成后，在工程的类试图中可以看到创建的方法类接口 “<strong>.idl</strong>“ 文件。<br>为其添加方法：</p>
<p>类试图 -&gt; “ISuperMath” -&gt; 右键 “添加” -&gt; “添加方法” 接口。<br><img src="18.png"><br><img src="19.png"></p>
<h4 id="接口类方法的实现"><a href="#接口类方法的实现" class="headerlink" title="接口类方法的实现"></a>接口类方法的实现</h4><p><img src="20.png"></p>
<p>由于微软封装的这套代码内部实现的自动写入注册表等方法，所以在接口方法实现完成后，就可以进行编译。VS需要使用<strong>管理员身份</strong>进行运行（提权），打开对应的 ATL 项目，进行编译，注册表才能写入成功。<br><img src="21.png"></p>
<blockquote>
<p>微软为了是软件开发者、插件使用者更方便的使用插件，”<strong>.idl</strong>“ 编译生成的 “<strong>.tlb</strong>“ 文件的格式是 “<strong>MSFT</strong>“ 开头的，使用 VS 自动创建编译的程序，程序编译后没有生成对应的 “<strong>.tbl</strong>“ 文件，其文件被合并到了 对应的 “<strong>.dll</strong>“ 文件中。</p>
</blockquote>
<p>使用的时候，将 “<strong>.dll</strong>“ 文件当作头文件使用即可。注意：插件和使用插件程序的兼容性问题。</p>
<h4 id="接口类方法的使用"><a href="#接口类方法的使用" class="headerlink" title="接口类方法的使用"></a>接口类方法的使用</h4><h5 id="VB"><a href="#VB" class="headerlink" title="VB"></a>VB</h5><p>使用插件的程序使用 VB 编写。</p>
<blockquote>
<p>创建一个 VB 程序，使用插件前需要在其程序中包含头文件（.dll）。</p>
</blockquote>
<p>点击项目 -&gt; 添加引用 -&gt; “引用管理器” COM -&gt; 通过 “浏览” 定位目标插件：</p>
<p><img src="22.png"></p>
<p>在窗口上放一个按钮控件，双击控件，在其内部实现插件中的方法即可，操作示例：</p>
<p><img src="23.png"></p>
<h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><p>创建对应的程序，将插件编译后对应的 “<strong>xxx_i.c</strong>“ 和 “<strong>xxx_i.h</strong>“ 文件导入到使用插件的程序中即可：</p>
<p><img src="24.png"></p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// CppTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ATLSuperMath_i.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 方法1</span><br>  <span class="hljs-comment">//CoInitialize(NULL);</span><br>  <span class="hljs-comment">//IClassFactory* pFactory = NULL;</span><br>  <span class="hljs-comment">//HRESULT hr = CoGetClassObject(</span><br>  <span class="hljs-comment">//  CLSID_CSuperMath, CLSCTX_INPROC_SERVER,</span><br>  <span class="hljs-comment">//  NULL, IID_IClassFactory, (void**)pFactory);</span><br>  <span class="hljs-comment">//if (FAILED(hr))</span><br>  <span class="hljs-comment">//&#123;</span><br>  <span class="hljs-comment">//  return 0;</span><br>  <span class="hljs-comment">//&#125;</span><br>  <span class="hljs-comment">//ISuperMath* pSuperMath = NULL;</span><br>  <span class="hljs-comment">//pFactory-&gt;CreateInstance(NULL, IID_ISuperMath, (void**)&amp;pSuperMath);</span><br>  <br>  <span class="hljs-comment">// 方法2</span><br>  CoInitialize(<span class="hljs-literal">NULL</span>);<br>  ISuperMath* pSuperMath = <span class="hljs-literal">NULL</span>;<br>  CoCreateInstance(CLSID_SuperMath, <span class="hljs-literal">NULL</span>, <br>    CLSCTX_INPROC_SERVER, IID_ISuperMath, <br>    (<span class="hljs-keyword">void</span>**)&amp;pSuperMath);<br>  <br>  <span class="hljs-keyword">long</span> nRet = <span class="hljs-number">0</span>;<br>  pSuperMath-&gt;Add(<span class="hljs-number">999</span>, <span class="hljs-number">1</span>, &amp;nRet);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;999 + 1 = %d\n&quot;</span>, nRet);<br>  <br>  <span class="hljs-comment">// 使用 CoCreateInstance 需要手动调用 Release</span><br>  pSuperMath-&gt;Release();<br>  CoUninitialize();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用微软的智能指针加载插件"><a href="#使用微软的智能指针加载插件" class="headerlink" title="使用微软的智能指针加载插件"></a>使用微软的智能指针加载插件</h4><blockquote>
<p><strong>CComPtr</strong> -&gt; 头文件：<strong>atlbase.h</strong></p>
</blockquote>
<p>其内部有引用计数，反初始化不能在析构前调用，适当的加一个作用域：</p>
<p><img src="25.png"><br><img src="26.png"></p>
<blockquote>
<p>使用的插件中没有提供头文件的可以使用 <strong>import</strong> 关键字 添加 “<strong>.dll</strong>“ 文件即可。</p>
</blockquote>
<h3 id="支持脚本语言的插件编写"><a href="#支持脚本语言的插件编写" class="headerlink" title="支持脚本语言的插件编写"></a>支持脚本语言的插件编写</h3><p>使用插件的步骤：</p>
<ul>
<li>包含头文件</li>
<li>调用插件中的方法</li>
</ul>
<p>有些脚本语言没有头文件概念（html）,例如：<br><img src="27.png"></p>
<p>之前定义的插件不能再脚本语言上使用，使用新的插件设计方式：</p>
<blockquote>
<p>Invoke(“Add”, 10, 20); – 将需要调用函数的名称字符串进行传递，插件通过字符串查询虚表。</p>
</blockquote>
<p>通过 ATL 创建新的插件，创建一个新工程，之后创建接口类：</p>
<p>解决方案 -&gt; 右键项目名（这里以ATLSuperMath为例）-&gt; 添加 -&gt; 新建项 -&gt; ATL -&gt; “ATL简单对象”：（选项 -&gt; 接口使用<strong>双重</strong>）<br><img src="28.png"></p>
<blockquote>
<p>选择 “<strong>双重</strong>“ 后，定义的接口类 “<strong>ISuperMath</strong>“ 的基类变成了 “<strong>IDispatch</strong>“，而 “<strong>IDispatch（自动化接口）</strong>“ 的基类是 “<strong>IUnknown</strong>“。</p>
</blockquote>
<p><img src="29.png"></p>
<p>同样，添加插件方法后并实现，之后进行编译，插件自动进行注册（注意：VS 需要使用管理员身份）</p>
<h4 id="支持脚本语言插件的使用"><a href="#支持脚本语言插件的使用" class="headerlink" title="支持脚本语言插件的使用"></a>支持脚本语言插件的使用</h4><h5 id="VB-1"><a href="#VB-1" class="headerlink" title="VB"></a>VB</h5><p>编写脚本，脚本代码示例：</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">set</span> obj = CreateObject(<span class="hljs-string">&quot;SuperMath.1.1&quot;</span>)  <br>  MsgBox <span class="hljs-string">&quot;1024 + 996 = &quot;</span> &amp; obj.Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">set</span> obj = <span class="hljs-literal">nothing</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p> CreateObject(“SuperMath.1.1”)  –&gt; “<strong>SuperMath.1.1</strong>“ 为 “<strong>ProgID</strong>“</p>
</blockquote>
<p><img src="30.png"></p>
<h5 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h5><blockquote>
<p><strong><a href="https://docs.microsoft.com/en-us/windows/win32/winauto/idispatch-interface">IDispatch（自动化接口）</a></strong></p>
</blockquote>
<p><img src="31.png"></p>
<p>新建 <strong>.cpp</strong> 工程，在程序中不包含头文件，使用 “<strong>CLSIDFromProogID</strong>“ 函数通过 <strong>ProgID</strong> 获取对应的 <strong>GUID</strong>。</p>
<p>编译器会将脚本代码进行翻译，翻译的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;atlbase.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  CoInitialize(<span class="hljs-literal">NULL</span>);<br>  <br>  HRESULT hr;<br>  GUID clsid;<br>  hr = CLSIDFromProgID(OLESTR(<span class="hljs-string">&quot;SuperMath.1.1&quot;</span>), &amp;clsid);<br>  <br>  IDispatch *pDispatch = <span class="hljs-literal">NULL</span>;<br>  hr = CoCreateInstance(clsid, <span class="hljs-literal">NULL</span>, <br>    CLSCTX_INPROC_SERVER, <br>    IID_IDispatch, (<span class="hljs-keyword">void</span>**)&amp;pDispatch);<br>  <br>  <span class="hljs-comment">// 可以查询多个</span><br>  LPOLESTR szMember[<span class="hljs-number">1</span>] = &#123;OLESTR(<span class="hljs-string">&quot;Add&quot;</span>)&#125;;<br>  DISPID dispid[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  hr = pDispatch-&gt;GetIDsOfNames(<br>    IID_NULL, szMember, <span class="hljs-number">1</span>, <br>    LOCALE_USER_DEFAULT, dispid);<br>    <br>  <span class="hljs-comment">//变体</span><br>  CComVariant vars[<span class="hljs-number">2</span>];<br>  DISPPARAMS args = &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>  vars[<span class="hljs-number">0</span>] = <span class="hljs-number">1024</span>;<br>  vars[<span class="hljs-number">1</span>] = <span class="hljs-number">996</span>;<br>  args.cArgs = <span class="hljs-number">2</span>;<br>  args.rgvarg = vars;<br>  <br>  CComVariant Ret; <span class="hljs-comment">// 接收结果</span><br>  <span class="hljs-comment">// 调用</span><br>  hr = pDispatch-&gt;Invoke(dispid[<span class="hljs-number">0</span>], IID_NULL, <br>    LOCALE_USER_DEFAULT, DISPATCH_METHOD,<br>    &amp;args, &amp;Ret, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1024 + 996=%d\r\n&quot;</span>, Ret.intVal);<br>  CoUninitialize();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="32.png"></p>
<h3 id="带界面的插件"><a href="#带界面的插件" class="headerlink" title="带界面的插件"></a>带界面的插件</h3><p>在 Com 框架中叫：<strong>ActiveX</strong></p>
<p>创建一个 ATL 工程，工程创建后新建接口，选择 ATL -&gt; ATL 控件 （CCRClock）</p>
<p>配置：</p>
<ul>
<li>选项：复合控件、双重、连接点</li>
<li>接口：接口全部支持</li>
<li>其它默认即可</li>
</ul>
<p>新建接口完成后，便可以在 “<strong>CCRClock</strong>“ 对应的 对话框上添加控件，响应对应的消息，其和 MFC 操作相似：</p>
<p><img src="33.png"><br><img src="34.png"></p>
<p>对应的方法编写完成后，便可以进行编译。编译成功后，就可以使用该插件。</p>
<h4 id="带界面插件的使用"><a href="#带界面插件的使用" class="headerlink" title="带界面插件的使用"></a>带界面插件的使用</h4><h5 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h5><p>创建一个 “<strong>MFC 对话框</strong>“ 工程，并使用该插件。</p>
<blockquote>
<p>在创建的 “MFC 对话框” 工程对应的对话框内鼠标右键会弹出该菜单，选择 “<strong>插入 ActiveX控件</strong>“  – <strong>其会自动遍历注册表中可用的插件（找到之前创建的插件使用即可）</strong></p>
</blockquote>
<p><img src="35.png"><br><img src="36.png"></p>
<p>使用：</p>
<p>在对话框中插入 “<strong>ActiveX控件</strong>“ 后，编译当前程序即可：</p>
<p><img src="37.png"></p>
<h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>使用方法：<br>新建一个 “<strong>.html</strong>“ 文件，使用下面的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">classid</span>=<span class="hljs-string">&quot;clsid:32f076fb-ee79-433c-a33e-c4ecd2b7208a&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;600&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>clsid：</strong> 控件的 <strong>GUID</strong>，使用前提，需要进行注册表注册，同时有些浏览器会自动禁用 “<strong>ActiveX插件</strong>“，所以这里推荐使用微软的 “<strong>Internet Explorer</strong>“ 浏览器。</p>
</blockquote>
<p><img src="38.png"></p>
<h3 id="使用其它软件的插件"><a href="#使用其它软件的插件" class="headerlink" title="使用其它软件的插件"></a>使用其它软件的插件</h3><p>示例：</p>
<p><img src="39.png"></p>
<h3 id="逆向插件"><a href="#逆向插件" class="headerlink" title="逆向插件"></a>逆向插件</h3><p>正常情况下，插件不进行注册，其内部的方法是不可以使用的，所以在不需要进行注册表注册、以及只有一个 “<strong>.dll</strong>“ 文件的前提下使用插件中的方法，就需要对插件进行逆向分析。</p>
<blockquote>
<p>在只有一个 “<strong>.dll</strong>“ 文件的前提下可以使用 “<strong>OLE View</strong>“ 工具（VC++ 6.0）可以将 “<strong>.dll</strong>“ 中对应的 “<strong>.idl</strong>“ 文件进行还原。之后在使用插件的工程中新建一个 “<strong>.idl</strong>“ 文件，并进行编译，将生成的 “<strong>xxx_h.h</strong>“ 以及 “<strong>xxx_i.c</strong>“ 进行包含。</p>
</blockquote>
<p>操作如下：</p>
<p><img src="40.png"><br><img src="41.png"><br><img src="42.png"></p>
<blockquote>
<p>破解思路，找到使用的插件方法其在 “<strong>.dll</strong>“ 中的代码位置，修改代码。</p>
</blockquote>
<ul>
<li>通过 “<strong>CoCreateInstance</strong>“ 获取类工厂，通过其地址获取虚表</li>
<li>通过虚表首地址计算出 <strong>派生类</strong> 也就是插件中的 “<strong>Add</strong>“ 函数的地址</li>
<li><strong>Debug</strong> 版调试下会有调转，需要找到真正的 “<strong>Add</strong>“ 方法的代码地址，通过反汇编观察修改指定位置的代码即可。</li>
</ul>
<p>操作示例：</p>
<p><img src="43.png"><br><img src="44.png"><br><img src="45.png"><br><img src="46.png"><br><img src="47.png"><br><img src="48.png"></p>
<blockquote>
<p><strong>Add 方法在内存中的真实地址计算方法：</strong><br><code>Add 方法在虚表中的地址 + 地址上的值（向右移一个字节）+ 5</code><br><code>0x792C1005 + 0x00017906 + 5 = 0x792D8910</code></p>
</blockquote>
<p><img src="49.png"></p>
<blockquote>
<p>这样每次使用插件中的方法时，都需要在内存中找到其真正的代码地址，并进行修改，比较繁琐。由于之前的测试可以准确的找到其真正的地址，为了下次可以直接使用插件中的 “<strong>Add</strong>“ 方法，所以在找到其真正地址的时候，就应该将 “<strong>.dll</strong>“ 文件通过 “<strong>WinHex</strong>“ 或者其它二进制工具进行修改内存。</p>
</blockquote>
<p>操作示例：可以搜索插件对应的方法在内存中的真实结束的地址（这里以 C2 10 00 为例进行搜索）</p>
<p><img src="50.png"><br><img src="51.png"></p>
]]></content>
      <categories>
        <category>COM</category>
      </categories>
      <tags>
        <tag>跨语言插件的编写以及使用</tag>
      </tags>
  </entry>
</search>
